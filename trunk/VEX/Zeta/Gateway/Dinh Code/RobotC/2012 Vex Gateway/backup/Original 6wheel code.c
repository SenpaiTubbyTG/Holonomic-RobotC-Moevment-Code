#pragma config(Sensor, in1,    L1,                  sensorLineFollower)
#pragma config(Sensor, in2,    M2,                  sensorLineFollower)
#pragma config(Sensor, in3,    R3,                  sensorLineFollower)
#pragma config(Sensor, dgtl1,  encR,                sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encL,                sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  Eye1,                sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  Eye2,                sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  Estop,               sensorTouch)
#pragma config(Motor,  port2,           Right1,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           Right2,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           Right3,        tmotorNormal, openLoop)
#pragma config(Motor,  port5,           Left1,         tmotorNormal, openLoop)
#pragma config(Motor,  port6,           Left2,         tmotorNormal, openLoop)
#pragma config(Motor,  port7,           Left3,         tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

int count = 0;

const bool Rightside = true;
const bool Leftside = false;
const bool Left = true;
const bool Right = false;
const bool Foward = true;
const bool Backward = false;


int distance()
{
  return (abs(SensorValue[encL]) + abs(SensorValue[encR]))/2;
}

void off()
{
  motor[port1] = 0;
  motor[Right1] = 0;
  motor[Right2] = 0;
  motor[Right3] = 0;
  motor[Left1] = 0;
  motor[Left2] = 0;
  motor[Left3] = 0;
  motor[port8] = 0;
  motor[port9] = 0;
  motor[port10] = 0;

}

void stopdrive()
{
  motor[Right1] = 0;
  motor[Right2] = 0;
  motor[Right3] = 0;
  motor[Left1] = 0;
  motor[Left2] = 0;
  motor[Left3] = 0;

}



void clearenc()
{
  SensorValue[encL] = 0;
  SensorValue[encR] = 0;
}





void rampage(char power)
{
  if(SensorValue[encL] > SensorValue[encR])
  {
    motor[Right1] = power;
    motor[Right2] = power;
    motor[Right3] = power;
    motor[Left1] = power-1;
    motor[Left2] = power-1;
    motor[Left3] = power-1;

  }
  else if(SensorValue[encR]> SensorValue[encL])
  {
    motor[Right1] = power-1;
    motor[Right2] = power-1;
    motor[Right3] = power-1;
    motor[Left1] = power;
    motor[Left2] = power;
    motor[Left3] = power;
  }
  else
  {
    motor[Right1] = power;
    motor[Right2] = power;
    motor[Right3] = power;
    motor[Left1] = power;
    motor[Left2] = power;
    motor[Left3] = power;

  }


}

//////////////////////////////encoder///////////////////////////////////////
void Drive(bool direction, int ticks, char power)
{
  switch(direction){
    case Foward:
  clearenc();
  while(distance() < ticks)
  {
    if (SensorValue[encL] > SensorValue[encR])
    {
    motor[Right1] = power;
    motor[Right2] = power;
    motor[Right3] = power;
    motor[Left1] = power-1;
    motor[Left2] = power-1;
    motor[Left3] = power-1;
  }
    else if(SensorValue[encR] > SensorValue[encL])
    {
    motor[Right1] = power-1;
    motor[Right2] = power-1;
    motor[Right3] = power-1;
    motor[Left1] = power;
    motor[Left2] = power;
    motor[Left3] = power;
  }
    else
    motor[Right1] = power;
    motor[Right2] = power;
    motor[Right3] = power;
    motor[Left1] = power;
    motor[Left2] = power;
    motor[Left3] = power;
  }//while
  off();
  break;
  ///////////////backwards////////////////////////////////////////
      case Backward:
  clearenc();
  while(distance() < ticks)
  {
    if (SensorValue[encL] > SensorValue[encR])//if the left side is faster than the rightside...
    {
    motor[Right1] = -power+1;
    motor[Right2] = -power+1;
    motor[Right3] = -power+1;
    motor[Left1] = -power;
    motor[Left2] = -power;
    motor[Left3] = -power;
  }
    else if(SensorValue[encR] > SensorValue[encL])//if the right side is is faster than the right side...
    {
    motor[Right1] = -power;
    motor[Right2] = -power;
    motor[Right3] = -power;
    motor[Left1] = -power+1;
    motor[Left2] = -power+1;
    motor[Left3] = -power+1;
  }
    else
    motor[Right1] = -power;
    motor[Right2] = -power;
    motor[Right3] = -power;
    motor[Left1] = -power;
    motor[Left2] = -power;
    motor[Left3] = -power;
  }//while
  off();
  break;

}//switch
off();
allMotorsOff();
}
void turn(bool direction,int ticks, int power)
{
  clearenc();
  ClearTimer(T4);
  switch(direction){
    case Right:
    clearenc();
    while(distance() <= ticks)
    {
     motor[Right1] = -power;
     motor[Right2] = -power;
     motor[Right3] = -power;
     motor[Left1] = power;
     motor[Left2] = power;
     motor[Left3] = power;


   }
   off();
   break;
   case Left:
   clearenc();
   while(distance() <= ticks ){
     motor[Right1] = power;
     motor[Right2] = power;
     motor[Right3] = power;
     motor[Left1] = -power;
     motor[Left2] = -power;
     motor[Left3] = -power;

   }//while
   off();
   break;

 }//switch
off();
allMotorsOff();

}

/////////////////////////////////motors///////////////////////////////////////
void veer(bool direction,char power)
{

  switch (direction){
  case Left:
    motor[Right1] = power;
    motor[Right2] = power;
    motor[Right3] = power;
    motor[Left1] = power-50;
    motor[Left2] = power-50;
    motor[Left3] = power-50;
    break;
  case Right:
    motor[Right1] = power-50;
    motor[Right2] = power-50;
    motor[Right3] = power-50;
    motor[Left1] = power;
    motor[Left2] = power;
    motor[Left3] = power;
    break;

  }


}//Case
void rampageturn(bool direction, int power)
{
  switch(direction){
    case Left:
    motor[Right1] = -power;
    motor[Right2] = -power;
    motor[Right3] = -power;
    motor[Left1] = power;
    motor[Left2] = power;
    motor[Left3] = power;
    break;
    case Right:
    motor[Right1] = -power;
    motor[Right2] = -power;
    motor[Right3] = -power;
    motor[Left1] = power;
    motor[Left2] = power;
    motor[Left3] = power;
  }
  }
////////////////////////////////sonars////////////////////////////////////////////////////
void Sonarstraight(short ticks, short time, char distancefromwall,bool right)

{
  clearenc();
  ClearTimer(T4);
  switch(right){
  case Leftside:
    while(distance()< ticks || time1[T4] < time)
    {
      if(SensorValue[Eye1] > distancefromwall)
        veer(Left,100);
      else if(SensorValue[Eye1] < distancefromwall)
        veer(right,100);
      else
        rampage(100);
    }
    off();
    break;



  case Rightside:
    while(distance() < ticks || time1[T4] < time)
    {
      if(SensorValue[Eye2] > distancefromwall)// if you are to far from the wall veer in
        veer(Right,100);
      else if(SensorValue[Eye2] < distancefromwall)// if you are too close veer out.
        veer(Left,100);
      else// if you are neither close nor far, go fowards with the encoders...
        rampage(100);
    }
    off();
    break;
  }//end of func.
}




void foward_until_light(short time)
{
  while(SensorValue[M2] >200 || time1[T4] <= time)
  {
    rampage(127);
  }
  stopdrive();
}
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  clearenc();
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task e_stop()
{
  while(true)
  {
    if(SensorValue(Estop) == 1)
    {
      StopAllTasks(); // this ends the program
    }
    wait1Msec(10);  // this prevents the current task from hogging the CPU
  }
}



task autonomous()
{
  StartTask(e_stop);
  clearenc();



 turn(Left,400,127);
 turn(Right,400,127);
 Drive(Foward,2000,50);
 Drive(Backward,1000, 127);


  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////



task usercontrol()
{
  // User control code here, inside the loop
  StartTask(e_stop);
  while (true)
  {



    motor[Right1] = (vexRT[Ch2]-vexRT[Ch1]);
    motor[Right2] = (vexRT[Ch2]-vexRT[Ch1]);
    motor[Right3] =  (vexRT[Ch2]-vexRT[Ch1]);
    motor[Left1] = (vexRT[Ch2]+vexRT[Ch1]);
    motor[Left2] =  (vexRT[Ch2]+vexRT[Ch1]);
    motor[Left3] =  (vexRT[Ch2]+vexRT[Ch1]);




  }

}//while
