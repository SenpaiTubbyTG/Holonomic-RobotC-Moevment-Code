#pragma config(Sensor, in1,    gyro,                sensorPotentiometer)
//*!!Code automatically generated by ‘ROBOTC’ configuration wizard               !!*//
//Program author:  Chris Siegert
//Vamfun@yahoo.com
//Mentor Vex Team 599 and 1508a
//Global Variables
//The gyro board scales the 3 volt chip to 4.533v with gain factor 1.511
//this gives 600 dps/volt scale at board
const int gyro_init_time_ms = 1000; //ms
const float sf_gyro = 600.*5./4095.;  //units dps_per_cnt = 600 dps/volt*5volt/4095cnts
const int gyro_dz = 2 ;// dead zone in a/d counts (approx .67 deg_per_sec per count)
const int gyro_int_step_size = 2; // integer ms step size 500 hz nominal
//Chip Vdd = 3v  and Nominal gyro voltage output = 1.5 v -> 4095*/3.3*2/3*1.5*1.511. = 1874 cnts
int gyro_bias = 1874;  //nominally 1874 cnts
int gyro_angle = 0; //gyro angle degs  1 deg resolution
int rate_cnts=0; //unbiased gyro rate a/d counts
int gyro_rate_x10 = 0;//unbiased gyro rate deg/sec*10

//Tasks
task Process_gyro()
{
float cum = 0;
//………………. initialize gyro …………………………….
time1[T1]= 0;
int count = 0;
while(time1[T1]< gyro_init_time_ms)
{
count++ ;
wait1Msec(1);// this gives about 1 count per ms to average
cum = cum + (float)(SensorValue[gyro]);

}
gyro_bias =  cum/count;
cum = 0;

//………………. integrate gyro……………………………….
while(true)
{
int dt = time1[T1];
rate_cnts = SensorValue[gyro]-gyro_bias;
gyro_rate_x10 =10*sf_gyro*(float)rate_cnts;

if(dt >=gyro_int_step_size)
{
float error = SensorValue[gyro]-gyro_bias;

if(error>gyro_dz || error< -gyro_dz)
{
cum = cum + dt*error*sf_gyro/1000.;  //integrate if |error| > dz
}
ClearTimer(T1); //reset timer after use rate pulse
}
gyro_angle= cum;//scale to 1 deg/sec resolution
}
}
task main()
{

StartTask (Process_gyro);

}
