#pragma config(Sensor, in1,    pot,                 sensorPotentiometer)
#pragma config(Sensor, in2,    ppot,                sensorPotentiometer)
#pragma config(Sensor, dgtl1,  touchl,              sensorTouch)
#pragma config(Sensor, dgtl2,  ncoderL,             sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  ncoderR,             sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchh,              sensorTouch)
#pragma config(Sensor, dgtl12, TouchGoal,           sensorTouch)
#pragma config(Motor,  port2,           DriveLF,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           DriveRF,       tmotorNormal, openLoop)
#pragma config(Motor,  port4,           DriveRB,       tmotorNormal, openLoop)
#pragma config(Motor,  port5,           DriveLB,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           lift1,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           lift2,         tmotorNormal, openLoop)
#pragma config(Motor,  port8,           lift3,         tmotorNormal, openLoop)
#pragma config(Motor,  port9,           lift4,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port10,          Claw,          tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(200)
/*
////////////////////////////////motor ports and explantion not code/////////////////////////////////////////////////////////
// Motor[drivetrain]                                                       \\
//backR = A<---power expander, port 4                                       \\
//backL = B,---power expander, port 5                                        \\
//frontR = port3                                                              \\
//frontL2 = port 2                                                             \\
//because my encoders were not working I had to name them dgtl...               \\
//left encoder = dgtl2 and right encoder = dgtl 4                                \\
//The Finders are just to make looking for the auton and teleop easier            \\
// In theory this program should score 20 points in auton and have a presetn teleop\\
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "Lance_Function_Library_v1.0.c" //Funtion Library

/*
Pot values NOT CODE
arm_grounded = 1400 or 1250
descore_lock_point = 1748 - 1250(1400) = 347
low_lock_point = 2550 - arm grounded = 1150
descore_high_point =
high_lock_point = 2775 - arm_grounded = 1475

*/

int arm_grounded;
int descore_low_point;
int low_lock_point;
int descore_high_point;
int high_lock_point;

void pre_auton()
{
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
  arm_grounded = SensorValue[pot];
  //////////////////////////////////////////////////////////////////////////////////////////////
  descore_low_point = arm_grounded + 329;    low_lock_point = arm_grounded + 1010; //low goal potentiometer reading
  //sets the low lock point based on the starting potentiometer point



  /////////////////////////////////////
  descore_high_point = arm_grounded + 1100;//<<<<---------------------------------------------------run debugger in tele op and see what this value is,
  //put that value where the XXXXX's are
  ////////////////////////////////////////



  high_lock_point = arm_grounded + 1500; //high goal potentiometer reading
  /////////////////////////////////////////////////////////////////////

  arm_grounded += 250;
}

task autonomous()
{
  // 2 Second Delay
    //this is the blue stack auton
  // Finder: blue Auton\\
   if  (SensorValue[ppot] >=  4 && SensorValue[ppot] <=1088 )
  { // 2 Second Delay

    //Clear Encoders
    SensorValue[dgtl4] = 0;
    SensorValue[dgtl2] = 0;

    motor[port10] = 127;
    wait1Msec(600);
    motor[port10] = 10;
    wait1Msec(1);

    while(SensorValue[dgtl4] > -35)  // While less than 5 rotations on the leftEncoder...
    {
      //...turn left
      motor[DriveLF] = -63;
      motor[DriveRF] = 63;
      motor[DriveRB] = 63;
      motor[DriveLB] = -63;
    }
    motor[port2] = 0;
    motor[port3] = 0;
    motor[port4] = 0;
    motor[port5] = 0;

    while(SensorValue[pot] < 1475)
    {
      motor[port6] = -100;
      motor[port7] = -100;
      motor[port8] = -100;
      motor[port9] =-100;
    }
    {

      motor[port6] =-5;
$ $ $ motov[tovt7]$=$-5;
$ $ $ motov[tovt8]$=$-5;
$ $ $ motov[poft=]$=$-5;
$   } $  SenworValue[dgtl2] = 0;
  $ SensorValue[dgtl4] = 0;
    while(SensorValue[dgtl4] < 195) //while the right encoder is less than 195 then...
    {
      //...Move Forward
      motor[port2] = 63;
      motor[port3] = 63;
      motor[port4] =63;
      motor[port5] = 63;
    }
    motor[port2] = 0;
    motor[port3] = 0;
    motor[port4] = 0;
    motor[port5] = 0;


    while(SensorValue[pot] > 937)
    {
      motor[port6] = 30;
      motor[port7] = 30;
      motor[port8] = 30;
      motor[port9] = 30;
    }


    motor[port6] = 0;
    motor[port7] = 0;
    motor[port8] = 0;
    motor[port9] = 0;


    motor[port10] = -127;
    wait1Msec(200);
    motor[port10] = 0;
    wait1Msec(1);
    while(SensorValue[dgtl4] > -215)  //while left encoder is less than -215 then...
    {
      //...Move back
      motor[port2] = -63;
      motor[port3] = -63;
      motor[port4] = -63;
      motor[port5] = -63;
    }
    motor[port2] = 0;
    motor[port3] = 0;
    motor[port4] = 0;
    motor[port5] = 0;


  }// if

  else if
    // this code is to jam the goal so the other team does not score\\
    //Finder:Smash                                                   \\
  (SensorValue[ppot] > 1400 && SensorValue[ppot] < 2500) // if pot is set between 6 and 2100 it will run red auton.
  {
    while (SensorValue[dgtl2] < 150){
      motor[DriveLB] = 127;
      motor[DriveLF] = 127;
      motor[DriveRB] = 127;
      motor[DriveRF] = 127;
    }
    motor[DriveLB] = 0;
    motor[DriveLF] = 0;
    motor[DriveRB] = 0;
    motor[DriveRF] = 0;
    wait1Msec(2000);

  }
  //Clear Encoders
  //Red is turns on the right.
  // Red stack score
  // Finder: Red auton
  else if(SensorValue[ppot] >= 2900 && SensorValue[ppot] <= 4095) // if pot is set between 6 and 2100 it will run red auton.
  {
    // 2 Second Delay

    //Clear Encoders
    SensorValue[dgtl4] = 0;
    SensorValue[dgtl2] = 0;

    motor[port10] = 127;
    wait1Msec(600);
    motor[port10] = 10;
    wait1Msec(1);

    while(SensorValue[dgtl2 ] > -42)
    {
      //...turn right
      motor[DriveLF] = 63;
      motor[DriveRF] = -63;
      motor[DriveRB] = -63;
      motor[DriveLB] = 63;
    }
    motor[port2] = 0;
    motor[port3] = 0;
    motor[port4] = 0;
    motor[port5] = 0;

    while(SensorValue[pot] < 1475)
    {
      motor[port6] = -100;
      motor[port7] = -100;
      motor[port8] = -100;
      motor[port9] =-100;
    }
    {

      motor[port6] =-5;
      motor[port7] = -5;
      motor[port8] = -5;
      motor[port9] = -5;
    }

    SensorValue[dgtl2] = 0;
    SensorValue[dgtl4] = 0;
    while(SensorValue[dgtl2] < 199)  // While less than 5 rotations on the leftEncoder...
    {
      //...Move Forward
      motor[port2] = 63;
      motor[port3] = 63;
      motor[port4] =63;
      motor[port5] = 63;
    }
    motor[port2] = 0;
    motor[port3] = 0;
    motor[port4] = 0;
    motor[port5] = 0;


    while(SensorValue[pot] > 937)
    {
      motor[port6] = 30;
      motor[port7] = 30;
      motor[port8] = 30;
      motor[port9] = 30;
    }


    motor[port6] = 0;
    motor[port7] = 0;
    motor[port8] = 0;
    motor[port9] = 0;


    motor[port10] = -127;
    wait1Msec(200);
    motor[port10] = 0;
    wait1Msec(1);
    while(SensorValue[dgtl2] > -215)  //while left encoder is less than -215 then...
    {
      //...Move back
      motor[port2] = -63;
      motor[port3] = -63;
      motor[port4] = -63;
      motor[port5] = -63;
    }
    motor[port2] = 0;
    motor[port3] = 0;
    motor[port4] = 0;
    motor[port5] = 0;





  }// auton red


  else
  { motor[Claw] = 0;
    motor[DriveLB] = 0;
    motor[DriveLF] = 0;
    motor[DriveRB] = 0;
    motor[DriveRF] = 0;
    motor[lift1] = 0;
    motor[lift2] = 0;
    motor[lift3] = 0;
    motor[lift4] = 0;
  }




}// task main


//lock(low_lock_point); //<-------------------------------------pot code


//USER CONTROL/////////////////////////////////////////////////////////////////
task usercontrol()
{
  pre_auton();
  int goal_lock = 0;  //0 for unlocked, -1 for low gal, 1 for high goal
  //calibration for potentiometer setting the arm
  /*int low_lock_point = SensorValue[in1] + 703; //low goal potentiometer reading
  //sets the low lock point based on the starting potentiometer point
  int high_lock_point = SensorValue[in1] + 1000; //high goal potentiometer reading*/
  //end calibrarion


  while(true)
  {
    //Arm/////////////////////////////////////////////////////////////////////////
    if(vexRT[Btn7L] == 1)//auto button close loop
    {
      goal_lock = -1;   //sets to low lock
    }
    else if(vexRT[Btn7U] == 1) {
      goal_lock = 1;	//sets to high lock
    }
    else if(vexRT[Btn7D] == 1) {// descore/ score on low goal...
        goal_lock = 2;
    }
    else if(vexRT[Btn7R] == 1) {//same as 7D...
        goal_lock = 2;
    }


    if(goal_lock == -1)
      lock(low_lock_point); //brings to low lock point
    else if(goal_lock == 1)
      lock(high_lock_point);//moves arm to high lock point
    ///////////////////////////////////////////////////////////////NEW STUFF TAKE THIS OUT IF IT DOESNT WORK
    else if (goal_lock == 2)
      lock(descore_low_point);//moves arm to descore lock point
    else if(goal_lock == 3)
      lock(descore_high_point);
    //////////////////////////////////////////////////////////////


     //Finder: Arm control
    switch(vexRT[Btn6U] - vexRT[Btn6D]) //manual arm control
    {
    case  1:motor[Lift1] = -127;
      motor[Lift2] = -127;
      motor[Lift3] = -127;
      motor[lift4] = -127;

      goal_lock = 0;  //unlocks arm
      break;

    case -1:motor[lift1] = 127;
      motor[lift2] = 127;
      motor[lift3] = 127;
      motor[lift4] = 127;
      goal_lock = 0;  //unlocks arm
      break;

    case  0:if(goal_lock == 0 ) {
        motor[lift1] = 0;
        motor[lift2] = 0;
        motor[lift3] = 0;
        motor[lift4] = 0;
        break;
      }//switch
    }

    // Finder: Claw
    switch(vexRT[Btn5U] - vexRT[Btn5D])
    {
    case  1:motor[Claw] = -127; //Close
      break;
    case -1:motor[Claw] = 127; //Open
      break;
    case  0:motor[Claw] = 0; //Do nothing
      break;
    }
    // Finder :Drive Train
    {	if(vexRT[Ch2] < 30 && vexRT[Ch2]> -30 && vexRT[Ch3] < 30 && vexRT[Ch3]> -30)
                {
                     motor[DriveLF] = 0;
                     motor[DriveRF] = 0;
                     motor[DriveRB] = 0;
                     motor[DriveLB] = 0;

}
      motor[DriveLF] = vexRT[Ch2];//left frotn motor
      motor[DriveRF] = vexRT[Ch3];//front right motor
      motor[DriveRB] = vexRT[Ch3];//right back motors
      motor[driveLB] = vexRT[Ch2];//Back left motor

    }




    // Shuts all motors down
    {

      if(vexRT[Btn8U] == 1)
      {
        motor[port1] = 0;
        motor[port6] = 0;
        motor[port7] = 0;
        motor[port10] = 0;



      }
    }

  }//while


}//taskusercontrol
