#pragma config(Sensor, in1,    SensorLineFarLeft,   sensorLineFollower)
#pragma config(Sensor, in2,    SensorLineLeft,      sensorLineFollower)
#pragma config(Sensor, in3,    SensorLineMiddle,    sensorLineFollower)
#pragma config(Sensor, in4,    SensorLineRight,     sensorLineFollower)
#pragma config(Sensor, in5,    SensorLineFarRight,  sensorLineFollower)
#pragma config(Sensor, in6,    SensorPotFourBar,    sensorPotentiometer)
#pragma config(Sensor, in7,    SensorPotClaw,       sensorPotentiometer)
#pragma config(Sensor, in8,    SensorPotAuto,       sensorPotentiometer)
#pragma config(Sensor, dgtl7,  SensorJumperAutoColor, sensorDigitalIn)
#pragma config(Sensor, dgtl8,  SensorJumperAutoPosition, sensorDigitalIn)
#pragma config(Sensor, dgtl9,  SensorEncoderDriveLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, SensorEncoderDriveRight, sensorQuadEncoder)
#pragma config(Motor,  port1,           MotorDriveLeft2, tmotorNormal, openLoop)
#pragma config(Motor,  port2,           MotorDriveLeft1, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           MotorClaw,     tmotorNormal, openLoop)
#pragma config(Motor,  port4,           MotorFourBarLeft2, tmotorNormal, openLoop)
#pragma config(Motor,  port5,           MotorFourBarLeft, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           MotorFourBarRight, tmotorNormal, openLoop)
#pragma config(Motor,  port7,           MotorFourBarRight2, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           MotorDescoringFork, tmotorNormal, openLoop)
#pragma config(Motor,  port9,           MotorDriveRight1, tmotorNormal, openLoop)
#pragma config(Motor,  port10,          MotorDriveRight2, tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!



//                                    _._
//                               _.-="_-         _
//                          _.-="   _-          | ||"""""""---._______     __..
//              ___.===""""-.______-,,,,,,,,,,,,`-''----" """""       """""  __'
//       __.--""     __        ,'                   o \           __        [__|
//  __-""=======.--""  ""--.=================================.--""  ""--.=======:    `~~`
// ]       [w] : /        \ : |========================|    : /        \ :  [w] :   `~~~~~`
// V___________:|          |: |========================|    :|          |:   _-"___`~~~~~~~~`
//  V__________: \        / :_|=======================/_____: \        / :__-"----- `~~~~~~~`
//  -----------'  ""____""  `-------------------------------'  ""____""               `~~~`

//  (\__/)
//  (='.')
// C(")(")

//Hi



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

int ValueFourBar; //The position you want the 4-bar to be in, can be set with the 4-bar variables for common positions.
int ValueClaw; //The position you want the claw to be in, usually the open/closed variables are used.
int ValueWait; //The value you want the desired sensor to reach before continuing on in autonomous mode.

bool StopWait; //Create the variable "StopWait" for knowing when to stop waiting.
bool ClawDone; //Used to signal wait function that claw task is done.
bool FourBarDone; //Used to signal wait function that 4-bar is done.
int MaxTimeClaw; //Create the varibale "MaxTimeClaw" for knowing when to quit trying to run the claw. (In case it gets stuck.)
int MaxTimeFourBar; //Create the variable "MaxTimeFourBar" for knowing when to quit trying to run the 4-bar. (In case it gets stuck.)

const int Forward = 1; //Variables used to tell the Drive function what the desired movement is - Forward/Backward, or spinning Left/Right.
const int Backward = 2;
const int Left = 3;
const int Right = 4;
const int ForwardLeft = 5;
const int ForwardRight = 6;
const int BackwardLeft = 7;
const int BackwardRight = 8;


//Autonomous preset values.

//The exact number values the claw reads when it is in the open and closed positions.
const int ClawOpenLimit = 1300;
const int ClawClosedLimit = 2325;

//The exact number values the drive encoders read when the robot makes a 45, 90, and 180 degree turn.
const int Spin45 = 253;
const int Spin90 = 505;
const int Spin180 = 1010;

//The exact number values the 4-bar reads in it's common positions; Floor, BottomBaseGoal, TopBaseGoal, BottomWallGoal, TopWallGoal, & UpperLimit.
const int FourBarFloor = 350;
const int FourBarBottomBaseGoal = 795;
const int FourBarTopBaseGoal = 1500;
const int FourBarBottomWallGoal = 1325;
const int FourBarTopWallGoal = 1930;
const int FourBarUpperLimit = 2300;

//The exact number values the line followers read when they are over the white tape line, the dark gray foam tiles, and then the midpoint.
const int Bright = 100;//  brightest reading any of the line followers reads at any one time.
const int Dark = 2300; // darkest reading any of the line followers reads at any one time.
const int MidPoint = 1175; // middle number between the brightest and the darkest reading any of the line followers reads.

//Autonomous variables and constants.
int AutoColor; //Your alliance's Color (Red or Blue).
const int Red = 1;
const int Blue = 2;

int AutoPosition; //The Position on the field (Near or Far). (Near = close to the drivers, Far = away from the drivers.)
const int Near = 1;
const int Far = 2;

int AutoMode; //Various Modes for the given color and position.
const int Defense = 1;
const int WallGoal_Ladder_FarWallGoal = 2;
const int NearBaseGoal_FarWallGoal = 3;
const int NearBaseGoal_Ladder_FarWallGoal = 4;
const int Skills = 5;



void pre_auton()
{
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                         Autonomous Tasks and Functions
//
// Below are the tasks and functions that the robot will use to drive around the field
// during the 20-second autonomous mode, and in the 60-second programming skills challenge.
//
/////////////////////////////////////////////////////////////////////////////////////////

void Drive(int MaxSpeedDrive, int Direction, string SensorDrive, int ValueDrive, int MaxTime = 0)
{
  //MaxSpeedDrive - The overall speed you want the robot to go.
  //Direction - Forwards, Backwards, Left, Right.
  //SensorDrive - What sensor being activated should stop the drive motors.
  //ValueDrive - When the desired sensor reaches this value the drive motors will stop.
  //MaxTime - If > 0 this limits driving to this number of miliseconds or until the desired sensor is reached, whichever comes first.

  int DistToMaxSpd1 = 100; //Time (actually distance) that the robot takes to speed up completely.
  int StartAndEnd1 = 0; //The distance from the start and end you want the robot to reach. (Should always be 0.)
  int HighestSpeed1 = 127; //The fastest speed you ever want the robot's drive motors to reach.
  int LowestSpeed1 = 50; //The slowest speed you ever want the robot's drive motors to reach.
  float CalculationY1 = HighestSpeed1 - LowestSpeed1; //Calculate y1-y2.
  float CalculationX1 = DistToMaxSpd1 - StartAndEnd1; //Calculate x1-x2.
  float Calculation1 = CalculationY1 / CalculationX1; //Calculate (y1-y2) / (x1-x2), which is the slope.

  int DistToMaxSpd2 = 500; //Time (actually distance) that the robot takes to slow down completely.
  int StartAndEnd2 = 0; //The distance from the start and end you want the robot to reach. (Should always be 0.)
  int HighestSpeed2 = 127; //The fastest speed you ever want the robot's drive motors to reach.
  int LowestSpeed2 = 50; //The slowest speed you ever want the robot's drive motors to reach.
  float CalculationY2 = HighestSpeed2 - LowestSpeed2; //Calculate y1-y2.
  float CalculationX2 = DistToMaxSpd2 - StartAndEnd2; //Calculate x1-x2.
  float Calculation2 = CalculationY2 / CalculationX2; //Calculate (y1-y2) / (x1-x2), which is the slope.

  int DistToMaxSpdTurn1 = 100; //Time (actually distance) that the robot takes to speed up completely.
  int StartAndEndTurn1 = 0; //The distance from the start and end you want the robot to reach. (Should always be 0.)
  int HighestSpeedTurn1 = 127; //The fastest speed you ever want the robot's drive motors to reach.
  int LowestSpeedTurn1 = 80; //The slowest speed you ever want the robot's drive motors to reach.
  float CalculationYTurn1 = HighestSpeedTurn1 - LowestSpeedTurn1; //Calculate y1-y2.
  float CalculationXTurn1 = DistToMaxSpdTurn1 - StartAndEndTurn1; //Calculate x1-x2.
  float CalculationTurn1 = CalculationYTurn1 / CalculationXTurn1; //Calculate (y1-y2) / (x1-x2), which is the slope.

  int DistToMaxSpdTurn2 = 300; //Time (actually distance) that the robot takes to slow down completely.
  int StartAndEndTurn2 = 0; //The distance from the start and end you want the robot to reach. (Should always be 0.)
  int HighestSpeedTurn2 = 127; //The fastest speed you ever want the robot's drive motors to reach.
  int LowestSpeedTurn2 = 70; //The slowest speed you ever want the robot's drive motors to reach.
  float CalculationYTurn2 = HighestSpeedTurn2 - LowestSpeedTurn2; //Calculate y1-y2.
  float CalculationXTurn2 = DistToMaxSpdTurn2 - StartAndEndTurn2; //Calculate x1-x2.
  float CalculationTurn2 = CalculationYTurn2 / CalculationXTurn2; //Calculate (y1-y2) / (x1-x2), which is the slope.

  bool StopDrive = false; //The boolean variable that is set to true when the robot should stop driving.
  int GivenMaxSpeedDrive = MaxSpeedDrive; //Save the MaxSpeed given by the user.
  int DirModLeft, DirModRight; //The direction modifiers.  Used to set negative sensor and drive motor values to positive for comparing.
  int MinSpeedDrive; //Minimum speed you want the drive motors to go.
  int EncoderValues; //Used to hold the combined value of left and right encoders.
  int NewMotorSpeed; //Used to do a large calculation and check if the new speed is faster or slower than the robot is supposed to go.

  //Set the direction modifiers to their correct values (positive or negative) based on the direction the robot is driving.
  if (Direction == Forward)
  {
    DirModLeft = 1;
    DirModRight = 1;
  }
  else if(Direction == Backward)
  {
    DirModLeft = -1;
    DirModRight = -1;
  }
  else if(Direction == Left)
  {
     DirModLeft = -1;
     DirModRight = 1;
  }
  else if (Direction == Right)
  {
    DirModLeft = 1;
    DirModRight = -1;
  }
  else if(Direction == ForwardLeft)
  {
    DirModLeft = 0;
    DirModRight = 1;
  }
  else if(Direction == ForwardRight)
  {
    DirModLeft = 1;
    DirModRight = 0;
  }
  else if(Direction == BackwardLeft)
  {
    DirModLeft = 0;
    DirModRight = -1;
  }
  else if(Direction == BackwardRight)
  {
    DirModLeft = -1;
    DirModRight = 0;
  }

  SensorValue[SensorEncoderDriveLeft] = 0; //Reset the left and right drive motors' encoders.
  SensorValue[SensorEncoderDriveRight] = 0;
  time1[T1] = 0; //Reset timer 1.

  motor[MotorDriveLeft2] = LowestSpeed1; //Set all the drive motors to a slow speed, so that the robot barely moves.
  motor[MotorDriveRight2] = LowestSpeed1;
  motor[MotorDriveRight1] = LowestSpeed1;
  motor[MotorDriveLeft1] = LowestSpeed1;

  while(StopDrive == false) //Continue to drive forwards until the desired event occurs.
  {
    EncoderValues = (DirModLeft * SensorValue[SensorEncoderDriveLeft] + DirModRight * SensorValue[SensorEncoderDriveRight]) / 2; //Set the average
    //encoder value based on the left and right drive motors' encoders.

    //Ramp-up/ramp-down code, speeds the robot up at the beginning of the trip, and slows it down at the end.
    if (EncoderValues < ValueDrive - DistToMaxSpd2) //Are we less then 1/2 way to stopping point? It may still be time to speed up.
    {
      if(Direction == Forward || Direction == Backward)
      {
        NewMotorSpeed = Calculation1 * (EncoderValues - DistToMaxSpd1) + HighestSpeed1;
      }
      else
      {
        NewMotorSpeed = CalculationTurn1 * (EncoderValues - DistToMaxSpdTurn1) + HighestSpeedTurn1;
      }

      if(NewMotorSpeed <= GivenMaxSpeedDrive) //If the robot can still be sped up...
      {
         MaxSpeedDrive = NewMotorSpeed; //... do so.
       }
    }

    else //Otherwise assume you are more than halfway to the desired stopping point, and it's about time to slow down.
    {
      if(Direction == Forward || Direction == Backward)
      {
        NewMotorSpeed = Calculation2 * ((ValueDrive - EncoderValues) - DistToMaxSpd2) + HighestSpeed2;
      }
      else
      {
        NewMotorSpeed = CalculationTurn2 * ((ValueDrive - EncoderValues) - DistToMaxSpdTurn2) + HighestSpeedTurn2;
      }

      if(NewMotorSpeed <= GivenMaxSpeedDrive) //If the robot can still be slowed down...
      {
        MaxSpeedDrive = NewMotorSpeed; //... do so.
      }
    }


    if(MaxSpeedDrive - 20 > LowestSpeed1) //Make sure that there is enough difference between the MaxSpeed and the LowestSpeed.
    {
      MinSpeedDrive = MaxSpeedDrive - 20; //If so calculate the MinSpeed based on the MaxSpeed.
    }

    else //Otherwise assume that the robot is going too slow for that to work...
    {
      MinSpeedDrive = LowestSpeed1; //... and set the MinSpeed to the LowestSpeed.
    }

    //Keep left and right encoder balanced.
    if(DirModLeft * SensorValue[SensorEncoderDriveLeft] > DirModRight * SensorValue[SensorEncoderDriveRight]) //Is left side ahead of right?
    {
      if(DirModRight * motor[MotorDriveRight2] >= MaxSpeedDrive)
      {
        if(DirModLeft * motor[MotorDriveLeft2] > MinSpeedDrive)
        {
          motor[MotorDriveLeft2] = motor[MotorDriveLeft2] - 1 * DirModLeft; //Slow down the left side.
          motor[MotorDriveLeft1] = motor[MotorDriveLeft1] - 1 * DirModLeft;
        }
      }
      else //Otherwise assume that the right drive motors are not at the maximum speed you want them to go...
      {
        motor[MotorDriveRight2] = motor[MotorDriveRight2] + 1 * DirModRight; //Slow down the right side.
        motor[MotorDriveRight1] = motor[MotorDriveRight1] + 1 * DirModRight;
      }
    }

    else if(DirModRight * SensorValue[SensorEncoderDriveRight] > DirModLeft * SensorValue[SensorEncoderDriveLeft]) //Is right side ahead of left?
    {
      if(DirModLeft * motor[MotorDriveLeft2] >= MaxSpeedDrive)
      {
        if(DirModRight * motor[MotorDriveRight2] > MinSpeedDrive)
        {
          motor[MotorDriveRight2] = motor[MotorDriveRight2] - 1 * DirModRight; //... slow down the right drive motors.
          motor[MotorDriveRight1] = motor[MotorDriveRight1] - 1 * DirModRight;
        }
      }
      else //Otherwise assume that the right drive motors are not at the maximum speed you want them to go...
      {
        motor[MotorDriveLeft2] = motor[MotorDriveLeft2] + 1 * DirModLeft; //Speed up the left side.
        motor[MotorDriveLeft1] = motor[MotorDriveLeft1] + 1 * DirModLeft;
      }
    }

    //If none of the drive motors are at the maximum speed you want them to go...
    if(DirModLeft * motor[MotorDriveLeft2] < MaxSpeedDrive && DirModRight * motor[MotorDriveRight2] < MaxSpeedDrive)
    {
      motor[MotorDriveLeft2] = motor[MotorDriveLeft2] + 1 * DirModLeft; //Speed up all the drive motors.
      motor[MotorDriveRight2] = motor[MotorDriveRight2] + 1 * DirModRight;
      motor[MotorDriveRight1] = motor[MotorDriveRight1] + 1 * DirModRight;
      motor[MotorDriveLeft1] = motor[MotorDriveLeft1] + 1 * DirModLeft;
    }

    //Otherwise if they are greater than the MaxSpeed...
    else if(DirModLeft * motor[MotorDriveLeft2] > MaxSpeedDrive || DirModRight * motor[MotorDriveRight2] > MaxSpeedDrive)
    {
      motor[MotorDriveLeft2] = motor[MotorDriveLeft2] - 1 * DirModLeft; //... slow down all the drive motors.
      motor[MotorDriveRight2] = motor[MotorDriveRight2] - 1 * DirModRight;
      motor[MotorDriveRight1] = motor[MotorDriveRight1] - 1 * DirModRight;
      motor[MotorDriveLeft1] = motor[MotorDriveLeft1] - 1 * DirModLeft;
    }


    //Stop driving when the sensor identified by SensorDrive reaches the desired value, or when the timer reaches the MaxTime.
    if(SensorDrive == "SensorEncoderDrive" && EncoderValues >= ValueDrive)
    {
      StopDrive = true;
    }
    else if(SensorDrive == "Time" && time1[T1] >= ValueDrive)
    {
      StopDrive = true;
    }
    else if(SensorDrive == "Line")
    {
      if(SensorValue[SensorLineFarLeft] < MidPoint || SensorValue[SensorLineLeft] < MidPoint || SensorValue[SensorLineMiddle] < MidPoint ||
      SensorValue[SensorLineRight] < MidPoint || SensorValue[SensorLineFarRight] < MidPoint) //If any of the line followers see the white line...
      {
        StopDrive = true;
      }
    }
    else if(MaxTime > 0 && time1[T1] >= MaxTime)
    {
      StopDrive = true;
    }
  }

  motor[MotorDriveLeft2] = 0; //Stop driving.
  motor[MotorDriveRight2] = 0;
  motor[MotorDriveRight1] = 0;
  motor[MotorDriveLeft1] = 0;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void LineFollow(int MaxSpeedDrive, string SensorDrive, int ValueDrive, int MaxTimeDrive = 0) //Use the line following task to follow the line for a
{ //desired ammount in autonomous mode, as well as programming skills.
  //MaxSpeedDrive - The overall speed you want the robot to go.
  //Direction - Forwards, Backwards, Left, Right.
  //SensorDrive - What sensor being activated should stop the drive motors.
  //ValueDrive - When the desired sensor reaches this value the drive motors will stop.
  //MaxTimeDrive - If > 0 this limits driving to this number of miliseconds or until the desired sensor is reached, whichever comes first.

  int DistToMaxSpd1 = 100; //Time (Actually distance.) that the robot takes to speed up completely.
  int StartAndEnd1 = 0; //The distance from the start that the robot should start ramping up. (Should always be 0.)
  int HighestSpeed1 = 127; //The fastest speed you ever want the robot's drive motors to reach in all of the autonomous code.
  int LowestSpeed1 = 70; //The slowest speed you ever want the robot's drive motors to reach in all of the autonomous code.
  float CalculationY1 = HighestSpeed1 - LowestSpeed1; //Calculate y1-y2.
  float CalculationX1 = DistToMaxSpd1 - StartAndEnd1; //Calculate x1-x2.
  float Calculation1 = CalculationY1 / CalculationX1; //Calculate (y1-y2) / (x1-x2), which is the slope.

  int DistToMaxSpd2 = 500; //Time (Actually distance.) that the robot takes to slow down completely.
  int StartAndEnd2 = 0; //The distance from the end you want the robot to reach. (Should always be 0.)
  int HighestSpeed2 = 127; //The fastest speed you ever want the robot's drive motors to reach in all of the autonomous code.
  int LowestSpeed2 = 70; //The slowest speed you ever want the robot's drive motors to reach in all of the autonomous code.
  float CalculationY2 = HighestSpeed2 - LowestSpeed2; //Calculate y1-y2.
  float CalculationX2 = DistToMaxSpd2 - StartAndEnd2; //Calculate x1-x2.
  float Calculation2 = CalculationY2 / CalculationX2; //Calculate (y1-y2) / (x1-x2), which is the slope.

  int const LoopDelay = 0;

  bool StopDrive = false;

  int FarLeft;  // value the far left line follower reads.
  int Left;     // value the left line follower reads.
  int Middle;   // value the middle line follower reads.
  int Right;    // value the right line follower reads.
  int FarRight; // value the far right line follower reads.

  int EncoderValues;  // combined value of both left and right encoders
  int NewMotorSpeed; //Used to do a large calculation and check if the new speed is faster or slower than the robot is supposed to go.

  bool Crossing; //Create the variable "Crossing" for if the robot reaches a + crossing in the white line.
  Crossing = false; // False = robot is not crossing a line perpendicular to the one it is following, True = It is

  int GivenMaxSpeedDrive; // maximum desired speed you want the robot to go.
  GivenMaxSpeedDrive = MaxSpeedDrive; //Set that variable to the variable that the user has already set.

  SensorValue[SensorEncoderDriveLeft] = 0; //Reset the left drive motors' encoder.
  SensorValue[SensorEncoderDriveRight] = 0; //Reset the right drive motors' encoder.
  time1[T1] = 0; //Reset timer 1.

  motor[MotorDriveLeft2] = LowestSpeed1; //Set all the drive motors to a slow speed, so that the robot barely moves.
  motor[MotorDriveRight2] = LowestSpeed1;
  motor[MotorDriveRight1] = LowestSpeed1;
  motor[MotorDriveLeft1] = LowestSpeed1;

  while(StopDrive == false) //Continue to drive forwards until the desired event occurs.
  {
    EncoderValues = (SensorValue[SensorEncoderDriveLeft] + SensorValue[SensorEncoderDriveRight]) / 2;

    //Ramp-up/ramp-down code, speeds the robot up at the beginning of the trip, and slows it down at the end.
    if(EncoderValues < ValueDrive - DistToMaxSpd2) //Are we less then 1/2 way to stopping point? It may still be time to speed up.
    {
      NewMotorSpeed = Calculation1 * (EncoderValues - DistToMaxSpd1) + HighestSpeed1;

      if(NewMotorSpeed <= GivenMaxSpeedDrive) //If the robot can still be sped up...
      {
        MaxSpeedDrive = NewMotorSpeed; //... do so.
      }
    }

    else //Otherwise assume you are more than halfway to the desired stopping point, and it's about time to slow down.
    {
      NewMotorSpeed = Calculation2 * ((ValueDrive - EncoderValues) - DistToMaxSpd2) + HighestSpeed2;

      if(NewMotorSpeed <= GivenMaxSpeedDrive) //If the robot can still be slowed down...
      {
        MaxSpeedDrive = NewMotorSpeed; //... do so.
      }
    }

    int NearDifference = 40;
    int FarDifference = 60;

    FarLeft = SensorValue[SensorLineFarLeft]; //Update the line sensor values.
    Left = SensorValue[SensorLineLeft];
    Middle = SensorValue[SensorLineMiddle];
    Right = SensorValue[SensorLineRight];
    FarRight = SensorValue[SensorLineFarRight];

    // If 3 adjacent sensors see white then you are crossing a line perpendicular to the one you are following
    if(FarLeft < MidPoint && Middle < MidPoint || Left < MidPoint && Right < MidPoint || Middle < MidPoint && FarRight < MidPoint ||
    FarLeft < MidPoint && FarRight < MidPoint)
    {
      Crossing = true;
    }

    else if(SensorValue[SensorLineFarLeft] < MidPoint) //If the far left sensor sees the white line...
    {
      if(SensorValue[SensorLineFarRight] < MidPoint) //... and if the far right sensor sees the white line too...
      {
        //... assume that the robot is over a + crossing in the line.
        //Ignore it and continue following the line.
      }
      else //... and otherwise assume that the robot is not over a + crossing in the white line...
      {
        motor[MotorDriveRight1] = MaxSpeedDrive; //... speed up the right drive motors,
        motor[MotorDriveRight2] = motor[MotorDriveRight1];

        motor[MotorDriveLeft1] = motor[MotorDriveRight1] - FarDifference; //and slow down the left drive motors.
        motor[MotorDriveLeft2] = motor[MotorDriveLeft1];
      }
    }

    else if(SensorValue[SensorLineFarRight] < MidPoint) //Otherwise if the far right sensor sees the white line...
    {
      if(SensorValue[SensorLineFarLeft] < MidPoint) //... and if the far left sensor sees the white line too...
      {
        //... assume that the robot is over a + crossing in the line.
        //Ignore it and continue following the line.
      }
      else //... and otherwise assume that the robot is not over a + crossing in the white line...
      {
        motor[MotorDriveLeft1] = MaxSpeedDrive; //... speed up the left drive motors,
        motor[MotorDriveLeft2] = motor[MotorDriveLeft1];

        motor[MotorDriveRight1] = motor[MotorDriveLeft1] - FarDifference; //and slow down the right drive motors.
        motor[MotorDriveRight2] = motor[MotorDriveRight1];
      }
    }

    else if(SensorValue[SensorLineLeft] < MidPoint) //Otherwise if the left sensor sees the white line...
    {
      motor[MotorDriveRight1] = MaxSpeedDrive; //... speed up the right drive motors,
      motor[MotorDriveRight2] = motor[MotorDriveRight1];

      motor[MotorDriveLeft1] = motor[MotorDriveRight1] - NearDifference; //and slow down the left motors.
      motor[MotorDriveLeft2] = motor[MotorDriveLeft1];
    }

    else if(SensorValue[SensorLineRight] < MidPoint) //Otherwise if the right sensor sees the white line...
    {
      motor[MotorDriveLeft1] = MaxSpeedDrive; //... speed up the left drive motors,
      motor[MotorDriveLeft2] = motor[MotorDriveLeft1];

      motor[MotorDriveRight1] = motor[MotorDriveLeft1] - NearDifference; //and slow down the right motors.
      motor[MotorDriveRight2] = motor[MotorDriveRight1];
    }

    else if(SensorValue[SensorLineMiddle] < MidPoint) //... and otherwise if the middle sensor sees the white line...
    {
      if(SensorValue[SensorEncoderDriveLeft] > SensorValue[SensorEncoderDriveRight]) //... and if the robot is turned to the right...
      {
        motor[MotorDriveRight1] = MaxSpeedDrive;
        motor[MotorDriveRight2] = motor[MotorDriveRight1];

        motor[MotorDriveLeft1] = motor[MotorDriveRight1] - NearDifference;
        motor[MotorDriveLeft2] = motor[MotorDriveLeft1];
      }
      else if(SensorValue[SensorEncoderDriveRight] > SensorValue[SensorEncoderDriveLeft]) //... and otherwise if the robot is turned to the left...
      {
        motor[MotorDriveLeft1] = MaxSpeedDrive;
        motor[MotorDriveLeft2] = motor[MotorDriveLeft1];

        motor[MotorDriveRight1] = motor[MotorDriveLeft1] - NearDifference;
        motor[MotorDriveRight2] = motor[MotorDriveRight1];
      }
    }

    if(SensorDrive == "SensorEncoderDrive" && EncoderValues > ValueDrive ) //If the desired sensor if the drive motors' encoders...
    {
      StopDrive = true; //... set "StopDrive" to true, so that the robot stops following the line.
    }
    else if(SensorDrive == "Time" && time1[T1] > ValueDrive) //Otherwise if the desired sensor is time...
    {
      StopDrive = true; //... set "StopDrive" to true, so that the robot stops following the line.
    }
    else if(SensorDrive == "Crossing" && Crossing == true) //Otherwise if the desired sensor is when the robot reaches a + crossing in the white line...
    {
      StopDrive = true; //... set "StopDrive" to true so that the robot stops following the line.
    }

    wait1Msec(LoopDelay);
  }

  motor[MotorDriveLeft2] = 0; //Stop following the line.
  motor[MotorDriveRight2] = 0;
  motor[MotorDriveRight1] = 0;
  motor[MotorDriveLeft1] = 0;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


task FourBar() //This task is used to monitor the 4-bar's position in autonomous mode, as well as the programming skills challenge.
{
  bool TimerFlag = false;
  int Difference;
  MaxTimeFourBar = 0;

  while(true) //Continue to monitor the 4-bar's position during the entire autonomous mode or programming skills challenge.
  {
	  while(time1[T3] < MaxTimeFourBar || MaxTimeFourBar == 0 || TimerFlag == false)
	  {
	    if(MaxTimeFourBar > 0 && TimerFlag == false)
	    {
	      time1[T3] = 0;
	      TimerFlag = true;
	    }

		  Difference = ValueFourBar - SensorValue[SensorPotFourBar];

		  if(SensorValue[SensorPotFourBar] < ValueFourBar) //... and if the four-bar is below the desired position...
	    {
	      motor[MotorFourBarLeft] = (0.15 * (Difference - 0)) + 20; //... calculate the power of the 4-bar's motors based on how far it is from where
	      motor[MotorFourBarRight] = motor[MotorFourBarLeft]; //it needs to be.
	      motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	      motor[MotorFourBarRight2] = motor[MotorFourBarLeft];
	    }

	    else if(SensorValue[SensorPotFourBar] > ValueFourBar) //... and otherwise if the four bar is above the desired position...
	    {
	      motor[MotorFourBarLeft] = (0.15 * (Difference - 60)) + 25; //... calculate the power of the 4-bar's motors based on how far off it is from
	      motor[MotorFourBarRight] = motor[MotorFourBarLeft]; //where it needs to be.
	      motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	      motor[MotorFourBarRight2] = motor[MotorFourBarLeft];
	    }
    }

    if(SensorValue[SensorPotFourBar] < (FourBarFloor + FourBarBottomBaseGoal) / 2)
	  {
	    motor[MotorFourBarLeft] = -10;
	    motor[MotorFourBarRight] = -10;
	    motor[MotorFourBarLeft2] = -10;
	    motor[MotorFourBarRight2] = -10;
	  }

		MaxTimeFourBar = 0;
		TimerFlag = false;
		FourBarDone = true; //Used to let the wait function know that the FourBar is done.
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


task Claw() //Use the claw task to open or close the claw in autonomous mode, as well as the programming skills challenge.
{
  bool TimerFlag = false;
  int Difference;
  MaxTimeClaw = 0;

  while(true)
  {
    while(time1[T2] < MaxTimeClaw || MaxTimeClaw == 0 || TimerFlag == false) //Wait until the desired event occurs.
	  {
	    if(MaxTimeClaw > 0 && TimerFlag == false)
	    {
	      time1[T2] = 0;
	      TimerFlag = true;
	    }

	    Difference = SensorValue[SensorPotClaw] - ValueClaw;

	    if(SensorValue[SensorPotClaw] < ValueClaw) //If the claw is being closed...
	    {
	      if(SensorValue[SensorPotClaw] > ClawClosedLimit) //... and if the claw has reached it's closed limit...
	      {
	        motor[MotorClaw] = 0; //... stop closing the claw.
	      }

	      else //... and otherwise assume that the claw has not yet reached it's closed limit...
	      {
	        motor[MotorClaw] = (0.23 * (0 - Difference)) + 25; //... and start closing the claw.
	      }
	    }
	    else if(SensorValue[SensorPotClaw] > ValueClaw) //Otherwise if the claw is being opened...
	    {
	      if(SensorValue[SensorPotClaw] < ClawOpenLimit) //... and if the claw has reached it's open limit...
	      {
	        motor[MotorClaw] = 0; //... stop opening the claw.
	      }

	      else //... and otherwise assume that the claw has not yet reached it's open limit...
	      {
	        motor[MotorClaw] = (0.08 * (0 - Difference)) + 17; //... and start opening the claw.
	      }
	    }
	  }

	  ClawDone = true;
	  MaxTimeClaw = 0;

	  if(SensorValue[SensorPotClaw] < ClawOpenLimit)
	  {
	    ValueClaw = ClawOpenLimit;
	  }

	  TimerFlag = false;
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void Wait(string SensorWait) //Use the wait function to wait until the desired event occurs in autonomous mode, as well as the programming skills
{ //challenge.
  StopWait = false; //Set "StopWait" to false, since the robot isn't supposed to stop waiting yet. (In fact it hasn't even started yet.)

  time1[T4] = 0; //Reset timer 4.
  ClawDone = false;
  FourBarDone = false;

  while(StopWait == false) //Wait until the desired event occurs.
  {
    if(SensorWait == "Claw") //Otherwise if the desired sensor is the claw's potentiometer...
    {
      if(SensorValue[SensorPotClaw] < ValueClaw - 30 && SensorValue[SensorPotClaw] > ValueClaw + 30 || ClawDone == true) //... and if the claw is
      { //at/near the desired position...
        StopWait = true; //... set "StopWait" to true, so that the robot stops waiting.
      }
    }

    else if(SensorWait == "FourBar") //Otherwise if the desired sensor is the four-bar's potentiometer...
    {
      if(SensorValue[SensorPotFourBar] > ValueFourBar - 100 && SensorValue[SensorPotFourBar] < ValueFourBar + 100 || FourBarDone == true) //... and
      { //if the four-bar is at/near the desired position...
        StopWait = true; //... set "StopWait" to true, so that the robot stops waiting.
      }
    }

    else if(SensorWait == "Time") //Otherwise if the desired sensor is time...
    {
      if(time1[T4] > ValueWait) //... and if the desired ammount of time has elapsed...
      {
        StopWait = true; //... set "StopWait" to true, so that the robot stops waiting.
      }

      else
      {
        StopWait = true; //If passed in an incorrect SensorWait value, stop immediately.
      }
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  ValueFourBar = SensorValue[SensorPotFourBar]; //Set desired four bar position to the current potentiometer value
  StartTask(FourBar); //Start monitoring the position of the four-bar.

  ValueClaw = SensorValue[SensorPotClaw]; //Set the desired claw position to the current potentiomiter value.
  StartTask(Claw); //Start monitoring the position of the claw.


  if(SensorValue[SensorJumperAutoColor] == 0) //If there is a jumper in port 7...
  {
    AutoColor = Red; //... set your alliance's color to Red.
  }
  else //Otherwise assume that there is no jumper...
  {
    AutoColor = Blue; //... and set your alliance's color to Blue.
  }

  if(SensorValue[SensorJumperAutoPosition] == 0) //If there is a jumper in port 8...
  {
    AutoPosition = Far; //... set your position on the field to Near.
  }
  else //Otherwise assume that there is no jumper...
  {
    AutoPosition = Near; //... and set your position on the field to Far.
  }

  if(SensorValue[SensorPotAuto] <= 840)
  {
    AutoMode = Defense;
  }

  if(SensorValue[SensorPotAuto] > 840 && SensorValue[SensorPotAuto] <= 1680)
  {
    AutoMode = WallGoal_Ladder_FarWallGoal;
  }

  if(SensorValue[SensorPotAuto] > 1680 && SensorValue[SensorPotAuto] <= 2520)
  {
    AutoMode = NearBaseGoal_FarWallGoal;
  }

  if(SensorValue[SensorPotAuto] > 2520 && SensorValue[SensorPotAuto] <= 3360)
  {
    AutoMode = NearBaseGoal_Ladder_FarWallGoal;
  }

  if(SensorValue[SensorPotAuto] > 3360)
  {
    AutoMode = Skills;
  }



  /////////////////////////////////////////////////////////////////////////////////////////
  //
  //                                    Defensive
  //
  // This autonomous routine is used to prevent the opponent from scoring.
  //
  // The robot drives forward at full power for the entire 20-second autonomous period. It is
  // possible to leave the preload scored on the wall-goal if the robot is placed on the far
  // side.
  //
  // The robot should be set up such that it is aiming straight for the opponent's robot, or
  // at the near base-goal.
  //
  //                                   Far Score: 7
  //                                  Near Score: 0
  //
  /////////////////////////////////////////////////////////////////////////////////////////
  if(AutoMode == Defense)
  {
    ValueFourBar = FourBarBottomBaseGoal; //Begin to raise the 4-bar to the height of the bottom of the base-goals.

    Drive(127, Forward, "Time", 25000); //Then drive forward for the entire 20-seconds of autonomous, running into the opponent.
  }



  /////////////////////////////////////////////////////////////////////////////////////////
  //
  //                          Wall-Goal, Ladder, Far Wall-Goal
  //
  // This autonomous routine scores on 1(or 2) goal(s) and drops the opponents' 4-stack in
  // the ladder.
  //
  // The robot scores the 2-stack on the near wall-goal (if on the near side, otherwise
  // simply leaves the preload tube on it), then grabs the opponents' 4-stack and drops it in
  // the ladder. Then if the robot is on the far side, it will follow the line, grab the
  // 4-stack and score it on the wall-goal.
  //
  // The robot should be set up such that the front of the back drive wheels are in line
  // virtically with the edge of the gray tile, and the wheels are on the colored tile. Also
  // the robot should be centered left-right such that it is in place to grab the 4-stack in
  // front of it.
  //
  //                                   Far Score: 20
  //                                   Near Score: 9
  //
  /////////////////////////////////////////////////////////////////////////////////////////
  else if(AutoMode == WallGoal_Ladder_FarWallGoal)
  {
    ValueFourBar = FourBarFloor; //Lower the 4-bar to the floor.

    if(AutoPosition == Near) //If the robot is on the near side...
    {
      MaxTimeClaw = 500;
      ValueClaw = ClawClosedLimit; //Close the claw around the 2-stack.
      Wait("Claw");

	    Drive(127, Backward, "SensorEncoderDrive", 1200); //Drive backward away from the near base goal to the middle of the colored tile.

	    Drive(60, Backward, "Line", 200); //Drive forward toward the 2-stack until the robot reaches the white tape line.

	    Drive(100, Backward, "SensorEncoderDrive", 300); //Drive forward toward the 2-stack and past the first white tape line.

	    Drive(60, Backward, "Line", 600); //Drive forward toward the 2-stack until the robot reaches the other white tape line.

	    Drive(70, Backward, "SensorEncoderDrive", 80);

      if(AutoColor == Blue) //Pivot toward the wall, so that the robot faces the opponents' 2-stack
      {
        Drive(127, BackwardRight, "SensorEncoderDrive", 275);
      }
      else
      {
        Drive(127, BackwardLeft, "SensorEncoderDrive", 275);
      }

      Drive(80, Backward, "SensorEncoderDrive", 1100);

      ValueFourBar = FourBarTopWallGoal; //Begin to raise the 4-bar to the height of the top of the wall-goals.

      wait1Msec(500);

      LineFollow(65, "Time", 3100); //Follow the line toward the wall-goal for 3 seconds until the robot hits the wall.

      Drive(70, Backward, "SensorEncoderDrive", 50); //Drive backward away from the wall-goal a little.

      if(AutoColor == Blue) //Spin a little to line up correctly with the wall-goal.
	    {
	      Drive(100, Right, "SensorEncoderDrive", 15);
	    }
	    else
	    {
	      Drive(100, Left, "SensorEncoderDrive", 15);
	    }

      MaxTimeFourBar = 1000;
      ValueFourBar = FourBarBottomWallGoal; //Lower the 4-bar to the height of the bottom of the wall-goals, placing the 2-stack on the wall-goal.
      Wait("FourBar");

      wait1Msec(500); //Wait for half a second for the tubes to settle.

      ValueClaw = ClawOpenLimit; //Open the claw, leaving the 2-stack scored on the wall-goal.

      Drive(100, Backward, "SensorEncoderDrive", 200); //Drive backward away from the wall-goal a little.

      ValueFourBar = FourBarFloor; //Begin to lower the 4-bar to the floor.

      if(AutoColor == Blue) //Spin 45 degrees to face the colored tile.
      {
        Drive(100, Right, "SensorEncoderDrive", 470);
      }
      else
      {
        Drive(100, Left, "SensorEncoderDrive", 470);
      }

      Drive(100, Forward, "SensorEncoderDrive", 400); //Drive forward toward the colored tile until the robot is past the first white tape line.

      Drive(100, Forward, "Line", 700); //Drive forwards until the robot reaches the white tape line.

      if(AutoColor == Blue) //Pivot 45 degrees to face the opponents' 4-stack.
      {
        Drive(100, ForwardRight, "SensorEncoderDrive", 600);
      }
      else
      {
        Drive(100, ForwardLeft, "SensorEncoderDrive", 600);
      }

      Drive(60, Forward, "SensorEncoderDrive", 600); //Drive forward up to the opponents' 4-stack.
    }



    else //Otherwise assume that the robot is on the far side...
	  {
	    Drive(127, Backward, "SensorEncoderDrive", 800); //Drive backward away from the 4-stack, until the robot is past the colored tile.

	    Drive(80, Backward, "Line", 200); //Drive backward away from the colored tile, until the robot reaches the white tape line.

	    if(AutoColor == Blue) //Pivot away from the wall 45 degrees to face the opponents' 4-stack.
	    {
	      Drive(110, ForwardRight, "SensorEncoderDrive", 175);
	    }
	    else
	    {
	      Drive(110, ForwardLeft, "SensorEncoderDrive", 175);
	    }

	    Drive(60, Forward, "SensorEncoderDrive", 600); //Drive forward up to the opponents' 4-stack.
	  }

    MaxTimeClaw = 500;
    ValueClaw = ClawClosedLimit; //Close the claw around the opponents' 4-stack.
    Wait("Claw");

    Drive(80, Forward, "SensorEncoderDrive", 300); //Drive forward along the line past the colored tile.

    LineFollow(70, "Crossing", 700); //Follow the line until the robot reaches the white tape line crossing.

    ValueFourBar = FourBarBottomWallGoal; //Begin to raise the 4-bar to the height of the bottom of the wall-goals.

    if(AutoColor == Blue) //Pivot 90 degrees to face the ladder.
	  {
	    Drive(100, ForwardRight, "SensorEncoderDrive", 350);
	  }
	  else
	  {
	    Drive(100, ForwardLeft, "SensorEncoderDrive", 350);
	  }

	  LineFollow(100, "Time", 2000); //Follow the line for 2 seconds, running up into the ladder and reaching the 4-stack inside it.

	  MaxTimeClaw = 400;
	  ValueClaw = ClawOpenLimit; //Open the claw, dropping the opponents' 4-stack into the ladder.
	  Wait("Claw");

	  Drive(100, Backward, "SensorEncoderDrive", 400); //Drive backward up to the white tape line crossing.

	  if(AutoColor == Blue) //Pivot 90 degrees to be parallel to the white tape line.
	  {
	    Drive(100, BackwardRight, "SensorEncoderDrive", 350);
	  }
	  else
	  {
	    Drive(100, BackwardLeft, "SensorEncoderDrive", 350);
	  }

	  if(AutoColor == Near) //If the robot is on the near side...
	  {
	    //... stop there.
	  }



	  else //Otherwise assume that the robot is on the far side...
	  {
	    Drive(100, Backward, "SensorEncoderDrive", 200); //Drive backward past the white tape line crossing.

	    LineFollow(70, "Crossing", 250); //Follow the line until the robot reaches the white tape line crossing.
	    LineFollow(80, "SensorEncoderDrive", 820); //Follow the line until a little before the robot reaches the 4-stack.
	    LineFollow(50, "SensorEncoderDrive", 300); //Follow the line slowly up to the 4-stack.

	    MaxTimeClaw = 500;
	    ValueClaw = ClawClosedLimit; //Close the claw around the 4-stack.
	    Wait("Claw");

	    ValueFourBar = FourBarTopWallGoal; //Begin to raise the 4-bar to the height of the top of the wall-goals.

	    Drive(70, Forward, "SensorEncoderDrive", 400); //Drive forward past the colored tile.

	    LineFollow(50, "SensorEncoderDrive", 515); //Follow the line up to the wall-goal.

	    if(AutoColor == Blue) //Spin a little to line up correctly with the wall-goal.
	    {
	      Drive(100, Right, "SensorEncoderDrive", 20);
	    }
	    else
	    {
	      Drive(100, Left, "SensorEncoderDrive", 20);
	    }

	    MaxTimeFourBar = 500;
	    ValueFourBar = FourBarBottomWallGoal; //Lower the 4-bar to the height of the bottom of the wall-goals, placing the 4-stack on the wall-goal.
	    Wait("FourBar");

	    wait1Msec(500); //Wait half a second to let the tubes settle.

	    ValueClaw = ClawOpenLimit; //Begin to open the claw.

	    Drive(100, Backward, "SensorEncoderDrive", 250); //Drive backward away from the wall-goal.

	    ValueFourBar = FourBarFloor; //Begin to lower the 4-bar to the floor.

	    if(AutoColor == Blue) //Spin to face the opponents' 2-stack.
	    {
	      Drive(100, Right, "SensorEncoderDrive", 210);
	    }
	    else
	    {
	      Drive(100, Left, "SensorEncoderDrive", 210);
	    }

	    Drive(70, Forward, "SensorEncoderDrive", 100); //Drive forward past the white tape line.

	    Drive(70, Forward, "Line", 800); //Drive forward until the robot reaches the other white tape line.

	    MaxTimeClaw = 500;
	    ValueClaw = ClawClosedLimit; //Close the claw around the opponents' 2-stack.
	    Wait("Claw");
	  }
  }



  /////////////////////////////////////////////////////////////////////////////////////////
  //
  //                           Near Base-Goal, Far Wall-Goal
  //
  // This autonomous routine scores on 1(or 2) goal(s) and drops the opponents' 4-stack in
  // the ladder.
  //
  // The robot scores the 2-stack on the near wall-goal (if on the near side, otherwise
  // simply leaves the preload tube on it), then grabs the opponents' 4-stack and drops it in
  // the ladder. Then if the robot is on the far side, it will follow the line, grab the
  // 4-stack and score it on the wall-goal.
  //
  // The robot should be set up such that the front of the back drive wheels are in line
  // virtically with the edge of the gray tile, and the wheels are on the colored tile. Also
  // the robot should be centered left-right such that it is in place to grab the 4-stack in
  // front of it.
  //
  //                                   Far Score: 26
  //                                  Near Score: 13
  //
  /////////////////////////////////////////////////////////////////////////////////////////



  else if(AutoMode == NearBaseGoal_FarWallGoal)
  {
    ValueFourBar = FourBarFloor; //Lower the 4-bar down to the floor.

    MaxTimeClaw = 500;
    ValueClaw = ClawClosedLimit; //Close the claw around the 4-stack.
    Wait("Claw");

    ValueFourBar = FourBarTopBaseGoal; //Begin to raise the 4-bar to the height of the top of the base-goals.

    if(AutoColor == Blue) //Spin to face the base-goal.
    {
      Drive(110, Right, "SensorEncoderDrive", 198);
    }
    else
    {
      Drive(110, Left, "SensorEncoderDrive", 205);
    }

    Drive(100, Forward, "SensorEncoderDrive", 220); //Drive forward toward the base-goal.

    MaxTimeFourBar = 1000;
    ValueFourBar = FourBarBottomBaseGoal; //Lower the 4-bar to the height of the bottom of the base-goals, placing the 4-stack on the base-goal.
    Wait("FourBar");

    MaxTimeClaw = 400;
    ValueClaw = ClawOpenLimit; //Open the claw, leaving the 4-stack scored.
    Wait("Claw");

    ValueFourBar = FourBarTopBaseGoal; //Begin to raise the 4-bar to the height of the top of the base-goals.

    if(AutoPosition == Near) //If the robot is on the near near side...
    {
      Drive(100, Backward, "SensorEncoderDrive", 220); //Drive backward away from the base-goal.

      if(AutoColor == Blue) //Spin toward the wall.
      {
        Drive(110, Left, "SensorEncoderDrive", 185);
      }
      else
      {
        Drive(110, Right, "SensorEncoderDrive", 185);
      }

      if(AutoColor == Blue) //Pivot a little away from the wall.
	    {
	      Drive(127, BackwardRight, "SensorEncoderDrive", 60);
	    }
	    else
	    {
	      Drive(127, BackwardLeft, "SensorEncoderDrive", 60);
	    }

	    Drive(100, Backward, "SensorEncoderDrive", 500); //Drive backward away from the near base goal to the middle of the colored tile.

	    if(AutoColor == Blue) //Spin 180 desgrees to face the 2-stack.
	    {
	      Drive(100, Right, "SensorEncoderDrive", 1100);
	    }
	    else
	    {
	      Drive(100, Left, "SensorEncoderDrive", 1100);
	    }

	    ValueClaw = ClawOpenLimit; //Open the claw.

	    Drive(100, Forward, "SensorEncoderDrive", 400); //Drive forward toward the 2-stack until the robot is past the colored tile.

	    Drive(70, Forward, "Line", 400); //Drive forward toward the 2-stack until the robot reaches the white tape line.

	    Drive(100, Forward, "SensorEncoderDrive", 300); //Drive forward toward the 2-stack and past the first white tape line.

	    Drive(70, Forward, "Line", 300); //Drive forward toward the 2-stack until the robot reaches the other white tape line.

	    MaxTimeClaw = 500;
      ValueClaw = ClawClosedLimit; //Close the claw around the 2-stack.
      Wait("Claw");

      if(AutoColor == Blue) //Pivot toward the wall, so that the robot faces the opponents' 2-stack
      {
        Drive(127, BackwardRight, "SensorEncoderDrive", 300);
      }
      else
      {
        Drive(127, BackwardLeft, "SensorEncoderDrive", 300);
      }

      Drive(100, Forward, "SensorEncoderDrive", 100); //Drive forward to meet the line.

      LineFollow(80, "SensorEncoderDrive", 300); //Follow the line a little.

      ValueFourBar = FourBarTopWallGoal; //Begin to raise the 4-bar to the height of the top of the wall-goals.

      if(AutoColor == Blue) //Spin 180 degrees to face the wall-goal.
      {
        Drive(110, Right, "SensorEncoderDrive", 1000);
      }
      else
      {
        Drive(110, Left, "SensorEncoderDrive", 1000);
      }

      LineFollow(50, "Time", 3000); //Follow the line toward the wall-goal for 3 seconds until the robot hits the wall.

      Drive(90, Backward, "SensorEncoderDrive", 75); //Drive backward away from the wall-goal a little.

      MaxTimeFourBar = 1000;
      ValueFourBar = FourBarBottomWallGoal; //Lower the 4-bar to the height of the bottom of the wall-goals, placing the 2-stack on the wall-goal.
      Wait("FourBar");

      wait1Msec(500); //Wait for half a second for the tubes to settle.

      ValueClaw = ClawOpenLimit; //Open the claw, leaving the 2-stack scored on the wall-goal.

      Drive(100, Backward, "SensorEncoderDrive", 150); //Drive backward away from the wall-goal a little.

      ValueFourBar = FourBarFloor; //Begin to lower the 4-bar to the floor.

      if(AutoColor == Blue) //Spin 45 degrees to face the colored tile.
      {
        Drive(100, Right, "SensorEncoderDrive", 350);
      }
      else
      {
        Drive(100, Left, "SensorEncoderDrive", 350);
      }

      Drive(100, Forward, "SensorEncoderDrive", 200); //Drive forward toward the colored tile until the robot is past the first white tape line.

      Drive(100, Forward, "Line", 300); //Drive forwards until the robot reaches the white tape line.

      if(AutoColor == Blue) //Pivot 45 degrees to face the opponents' 4-stack.
      {
        Drive(100, ForwardRight, "SensorEncoderDrive", 600);
      }
      else
      {
        Drive(100, ForwardLeft, "SensorEncoderDrive", 600);
      }

      Drive(60, Forward, "SensorEncoderDrive", 600); //Drive forward up to the opponents' 4-stack.
    }



    else //Otherwise assume that the robot is on the far side...
    {
      if(AutoColor == Blue)
      {
        Drive(90, BackwardLeft, "SensorEncoderDrive", 10);
      }
      else
      {
        Drive(90, BackwardRight, "SensorEncoderDrive", 10);
      }

      Drive(127, Backward, "Time", 3000); //Drive backward for 3 seconds, hitting the wall and straightening with it.

      Drive(90, Forward, "SensorEncoderDrive", 800); //Drive forward up to the white tape line.

      Drive(70, Forward, "Line", 200); //Drive forward until the robot sees the white tape line.

      Drive(70, Backward, "SensorEncoderDrive", 70); //Drive backward just a little.

      if(AutoColor == Blue) //Spin 45 degrees to face the 4-stack.
      {
        Drive(90, Left, "SensorEncoderDrive", 215);
      }
      else
      {
        Drive(90, Right, "SensorEncoderDrive", 215);
      }

      ValueFourBar = FourBarFloor; //Begin to lower the 4-bar to the floor.

      LineFollow(60, "Crossing", 700); //Follow the line until the robot reaches the crossing in the white tape line.
      LineFollow(60, "SensorEncoderDrive", 820); //Follow the line toward the 4-stack.
      LineFollow(50, "SensorEncoderDrive", 300); //Follow the line up to the 4-stack.

      MaxTimeClaw = 500;
      ValueClaw = ClawClosedLimit; //Close the claw around the 4-stack.
      Wait("Claw");

      ValueFourBar = FourBarTopWallGoal; //Begin to raise the 4-bar to the height of the top of the wall-goals.

      Drive(70, Forward, "SensorEncoderDrive", 300); //Drive forward toward the wall-goal until the robot is past the colored tile.

      LineFollow(50, "SensorEncoderDrive", 615); //Follow the line up to the wall-goal.

      if(AutoColor == Blue) //Spin just a little to line up perfectly with the wall-goal.
      {
        //Drive(100, Right, "SensorEncoderDrive", 10);
      }
      else
      {
        Drive(100, Left, "SensorEncoderDrive", 15);
      }

      MaxTimeFourBar = 500;
      ValueFourBar = FourBarBottomWallGoal; //Lower the 4-bar to the height of the bottom of the wall-goals.
      Wait("FourBar");

      wait1Msec(500); //Wait for half a second for the tubes to settle.

      ValueClaw = ClawOpenLimit; //Open the claw.

      Drive(100, Backward, "SensorEncoderDrive", 250); //Drive backward, leaving the 4-stack scored on the wall-goal.

      ValueFourBar = FourBarFloor; //Begin to lower the 4-bar to the floor.

      if(AutoColor == Blue) //Spin away from the wall to face the opponents' 2-stack.
      {
        Drive(100, Right, "SensorEncoderDrive", 265);
      }
      else
      {
        Drive(100, Left, "SensorEncoderDrive", 265);
      }

      Drive(70, Forward, "SensorEncoderDrive", 200); //Drive forward toward the opponents' 2-stack until the robot is past the first white line.

      Drive(65, Forward, "Line", 800); //Drive forward toward the opponents' 2-stack until the robot reaches the other white tape line.

      MaxTimeClaw = 500;
      ValueClaw = ClawClosedLimit; //Close the claw around the opponents' 2-stack.
      Wait("Claw");
    }
  }



  /////////////////////////////////////////////////////////////////////////////////////////
  //
  //                          Near Base-Goal, Ladder, Wall-Goal
  //
  // This autonomous routine scores on 1 goal and drops the opponents' 4-stack in the ladder.
  // The robot picks up the 4-stack and scores it on the near base-goal, then picks up the
  // opponents' 4-stack and drops it in the ladder. If the robot is on the far side it will
  // go on to pick up the other 4-stack, score it on the far wall-goal, then pick up the
  // opponents' 2-stack.
  //
  // The robot should be set up such that the front of the back drive wheels are in line
  // virtically with the edge of the gray tile, and the wheels are on the colored tile. Also
  // the robot should be centered left-right such that it is in place to grab the 4-stack in
  // front of it.
  //
  //                                    Far Score: 33
  //                                   Near Score: 20
  //
  /////////////////////////////////////////////////////////////////////////////////////////
  else if(AutoMode == NearBaseGoal_Ladder_FarWallGoal)
  {
    ValueFourBar = FourBarFloor; //Lower the 4-bar down to the floor.

    MaxTimeClaw = 500;
    ValueClaw = ClawClosedLimit; //Close the claw around the 4-stack.
    Wait("Claw");

    ValueFourBar = FourBarTopBaseGoal; //Begin to raise the 4-bar to the height of the top of the base-goals.

    if(AutoColor == Blue) //Spin to face the base-goal.
    {
      Drive(110, Right, "SensorEncoderDrive", 198);
    }
    else
    {
      Drive(110, Left, "SensorEncoderDrive", 208);
    }

    Drive(100, Forward, "SensorEncoderDrive", 220); //Drive forward toward the base-goal.

    MaxTimeFourBar = 1000;
    ValueFourBar = FourBarBottomBaseGoal; //Lower the 4-bar to the height of the bottom of the base-goals, placing the 4-stack on the base-goal.
    Wait("FourBar");

    MaxTimeClaw = 400;
    ValueClaw = ClawOpenLimit; //Open the claw, leaving the 4-stack scored.
    Wait("Claw");

    ValueFourBar = FourBarTopBaseGoal; //Begin to raise the 4-bar to the height of the top of the base-goals.

    Drive(100, Backward, "SensorEncoderDrive", 370);

    if(AutoColor == Blue)
    {
      Drive(100, Left, "SensorEncoderDrive", 156);
    }
    else
    {
      Drive(100, Right, "SensorEncoderDrive", 156);
    }

    wait1Msec(500);

    Drive(90, Backward, "SensorEncoderDrive", 1400); //Drive backwards for 3 seconds, hitting the wall and straightening with it.

    Drive(90, Backward, "Line", 300);

    ValueFourBar = FourBarFloor; //Begin to lower the 4-bar down to the floor.

    if(AutoColor == Blue) //Pivot to face the opponents' 4-stack.
    {
      Drive(127, BackwardLeft, "SensorEncoderDrive", 260);
    }
    else
    {
      Drive(127, BackwardRight, "SensorEncoderDrive", 260);
    }

    Drive(60, Forward, "SensorEncoderDrive", 400); //Drive forward up to the opponents' 4-stack.

    MaxTimeClaw = 500;
    ValueClaw = ClawClosedLimit; //Close the claw around the opponents' 4-stack.
    Wait("Claw");

    Drive(100, Forward, "SensorEncoderDrive", 300); //Drive forward toward the white tape line crossing to pass the colored tile.

    LineFollow(100, "Crossing", 600); //Follow the line until the robot reaches the white tape line crossing.

    ValueFourBar = FourBarBottomWallGoal; //Begin to raise the 4-bar to the height of the bottom of the wall-goals.

    if(AutoColor == Blue) //Pivot 90 degrees to face the ladder.
    {
      Drive(100, ForwardRight, "SensorEncoderDrive", 350);
    }
    else
    {
      Drive(100, ForwardLeft, "SensorEncoderDrive", 350);
    }

    LineFollow(100, "Time", 2000); //Follow the line for 2 seconds, running up into the ladder and reaching the 4-stack inside it.

    MaxTimeClaw = 400;
    ValueClaw = ClawOpenLimit; //Open the claw, dropping the opponents' 4-stack into the ladder.
    Wait("Claw");

    Drive(100, Backward, "SensorEncoderDrive", 400); //Drive backward up to the white tape line crossing.

    if(AutoColor == Blue) //Pivot 90 degrees to be parallel to the white tape line.
    {
      Drive(100, BackwardRight, "SensorEncoderDrive", 350);
    }
    else
    {
      Drive(100, BackwardLeft, "SensorEncoderDrive", 350);
    }

    if(AutoPosition == Near) //If the robot is on the near side...
    {
      //... stop there.
    }



    else //Otherwise assume that the robot is on the far side...
    {
	    Drive(100, Backward, "SensorEncoderDrive", 200); //Drive backward past the white tape line crossing.

	    LineFollow(70, "Crossing", 250); //Follow the line until the robot reaches the white tape line crossing.
	    LineFollow(80, "SensorEncoderDrive", 820); //Follow the line until a little before the robot reaches the 4-stack.
	    LineFollow(50, "SensorEncoderDrive", 300); //Follow the line slowly up to the 4-stack.

	    MaxTimeClaw = 500;
	    ValueClaw = ClawClosedLimit; //Close the claw around the 4-stack.
	    Wait("Claw");

	    ValueFourBar = FourBarTopWallGoal; //Begin to raise the 4-bar to the height of the top of the wall-goals.

	    Drive(70, Forward, "SensorEncoderDrive", 400); //Drive forward past the colored tile.

	    LineFollow(50, "SensorEncoderDrive", 515); //Follow the line up to the wall-goal.

	    if(AutoColor == Blue) //Spin a little to line up correctly with the wall-goal.
	    {
	      Drive(100, Right, "SensorEncoderDrive", 20);
	    }
	    else
	    {
	      Drive(100, Left, "SensorEncoderDrive", 20);
	    }

	    MaxTimeFourBar = 500;
	    ValueFourBar = FourBarBottomWallGoal; //Lower the 4-bar to the height of the bottom of the wall-goals, placing the 4-stack on the wall-goal.
	    Wait("FourBar");

	    wait1Msec(500); //Wait half a second to let the tubes settle.

	    ValueClaw = ClawOpenLimit; //Begin to open the claw.

	    Drive(100, Backward, "SensorEncoderDrive", 250); //Drive backward away from the wall-goal.

	    ValueFourBar = FourBarFloor; //Begin to lower the 4-bar to the floor.

	    if(AutoColor == Blue) //Spin to face the opponents' 2-stack.
	    {
	      Drive(100, Right, "SensorEncoderDrive", 210);
	    }
	    else
	    {
	      Drive(100, Left, "SensorEncoderDrive", 210);
	    }

	    Drive(70, Forward, "SensorEncoderDrive", 100); //Drive forward past the white tape line.

	    Drive(70, Forward, "Line", 800); //Drive forward until the robot reaches the other white tape line.

	    MaxTimeClaw = 500;
	    ValueClaw = ClawClosedLimit; //Close the claw around the opponents' 2-stack.
	    Wait("Claw");
	  }
  }



  else if(AutoMode == Skills)
  {
    ValueFourBar = FourBarFloor; //Lower the 4-bar down to the floor.

    MaxTimeClaw = 500;
    ValueClaw = ClawClosedLimit; //Close the claw around the 4-stack.
    Wait("Claw");

    ValueFourBar = FourBarTopBaseGoal; //Begin to raise the 4-bar to the height of the top of the base-goals.

    if(AutoColor == Blue) //Spin away from the wall to face the near base-goal.
    {
      Drive(90, Right, "SensorEncoderDrive", 198);
    }
    else
    {
      Drive(90, Left, "SensorEncoderDrive", 205);
    }

    Drive(100, Forward, "SensorEncoderDrive", 223); //Drive forward up to the base-goal.

    MaxTimeFourBar = 1000;
    ValueFourBar = FourBarBottomBaseGoal; //Lower the 4-bar to the height of the bottom of the base-goals, dropping the 4-stack onto the base-goal.
    Wait("FourBar");

    MaxTimeClaw = 600;
    ValueClaw = ClawOpenLimit; //Open the claw, leaving the 4-stack scored on the base-goal.
    Wait("Claw");

    MaxTimeFourBar = 1000;
    ValueFourBar = FourBarTopBaseGoal; //Raise the 4-bar to the height of the top of the base-goals.
    Wait("FourBar");

    if(AutoColor == Blue)
    {
      Drive(90, BackwardLeft, "SensorEncoderDrive", 10);
    }
    else
    {
      Drive(90, BackwardRight, "SensorEncoderDrive", 10);
    }

    Drive(127, Backward, "Time", 3000); //Drive backward for 3 seconds, hitting the wall and straightening with it.

    Drive(90, Forward, "SensorEncoderDrive", 800); //Drive forward up to the white tape line.

    Drive(70, Forward, "Line", 200); //Drive forward until the robot sees the white tape line.

    Drive(70, Backward, "SensorEncoderDrive", 70); //Drive backward just a little.

    if(AutoColor == Blue) //Spin 45 degrees to face the 4-stack.
    {
      Drive(90, Left, "SensorEncoderDrive", 215);
    }
    else
    {
      Drive(90, Right, "SensorEncoderDrive", 215);
    }

    ValueFourBar = FourBarFloor; //Begin to lower the 4-bar to the floor.

    LineFollow(60, "Crossing", 700); //Follow the line until the robot reaches the crossing in the white tape line.
    LineFollow(60, "SensorEncoderDrive", 820); //Follow the line toward the 4-stack.
    LineFollow(50, "SensorEncoderDrive", 300); //Follow the line up to the 4-stack.

    MaxTimeClaw = 500;
    ValueClaw = ClawClosedLimit; //Close the claw around the 4-stack.
    Wait("Claw");

    ValueFourBar = FourBarTopWallGoal; //Begin to raise the 4-bar to the height of the top of the wall-goals.

    Drive(70, Forward, "SensorEncoderDrive", 300); //Drive forward toward the wall-goal until the robot is past the colored tile.

    LineFollow(50, "SensorEncoderDrive", 615); //Follow the line up to the wall-goal.

    if(AutoColor == Blue) //Spin just a little to line up perfectly with the wall-goal.
    {
      //Drive(100, Right, "SensorEncoderDrive", 10);
    }
    else
    {
      Drive(100, Left, "SensorEncoderDrive", 15);
    }

    MaxTimeFourBar = 500;
    ValueFourBar = FourBarBottomWallGoal; //Lower the 4-bar to the height of the bottom of the wall-goals.
    Wait("FourBar");

    wait1Msec(500); //Wait for half a second for the tubes to settle.

    ValueClaw = ClawOpenLimit; //Open the claw.

    Drive(100, Backward, "SensorEncoderDrive", 250); //Drive backward, leaving the 4-stack scored on the wall-goal.

    ValueFourBar = FourBarFloor; //Begin to lower the 4-bar to the floor.

    if(AutoColor == Blue) //Spin away from the wall to face the opponents' 2-stack.
    {
      Drive(100, Right, "SensorEncoderDrive", 265);
    }
    else
    {
      Drive(100, Left, "SensorEncoderDrive", 265);
    }

    Drive(70, Forward, "SensorEncoderDrive", 200); //Drive forward toward the opponents' 2-stack until the robot is past the first white line.

    Drive(65, Forward, "Line", 800); //Drive forward toward the opponents' 2-stack until the robot reaches the other white tape line.

    MaxTimeClaw = 500;
    ValueClaw = ClawClosedLimit; //Close the claw around the opponents' 2-stack.
    Wait("Claw");

    ValueFourBar = FourBarTopWallGoal; //Begin to raise the 4-bar to the height of the top of the wall-goals.

    if(AutoColor == Blue) //Spin away from the wall to face the wall-goal.
    {
      Drive(100, Right, "SensorEncoderDrive", 340);
    }
    else
    {
      Drive(100, Left, "SensorEncoderDrive", 340);
    }

    LineFollow(60, "SensorEncoderDrive", 1330); //Follow the line up to the wall-goal.

    if(AutoColor == Blue) //Spin just a little to line up perfectly with the wall-goal.
    {
      //Drive(100, Right, "SensorEncoderDrive", 20);
    }
    else
    {
      Drive(100, Left, "SensorEncoderDrive", 20);
    }

    MaxTimeFourBar = 500;
    ValueFourBar = FourBarBottomWallGoal; //Lower the 4-bar to the height of the bottom of the wall-goals, dropping the 2-stack onto the wall-goal.
    Wait("FourBar");

    wait1Msec(500); //Wait for half a second for the tubes to settle.

    ValueClaw = ClawOpenLimit; //Open the claw, leaving the 2-stack scored on the wall-goal.

    Drive(100, Backward, "SensorEncoderDrive", 830); //Drive backward away from the wall-goal.

    if(AutoColor == Blue)
    {
      Drive(100, Right, "SensorEncoderDrive", 255);
    }
    else
    {
      Drive(100, Left, "SensorEncoderDrive", 255);
    }

    ValueFourBar = FourBarFloor;

    Drive(100, Forward, "SensorEncoderDrive", 200);

    Drive(90, Forward, "Line", 1300);

    ValueClaw = ClawClosedLimit;

    Drive(100, Forward, "SensorEncoderDrive", 100);

    if(AutoColor == Blue)
    {
      Drive(100, Right, "SensorEncoderDrive", 273);
    }
    else
    {
      Drive(100, Left, "SensorEncoderDrive", 273);
    }

    Drive(90, Forward, "SensorEncoderDrive", 300);

    LineFollow(80, "Crossing", 850);

    Drive(100, Forward, "SensorEncoderDrive", 100);

    if(AutoColor == Blue)
    {
      Drive(90, Left, "SensorEncoderDrive", 352);
    }
    else
    {
      Drive(90, Right, "SensorEncoderDrive", 352);
    }

    ValueFourBar = FourBarTopWallGoal;

    Drive(70, Forward, "Time", 2700);

    Drive(70, Backward, "SensorEncoderDrive", 100);

    MaxTimeFourBar = 1000;
    ValueFourBar = FourBarBottomWallGoal;
    Wait("FourBar");

    wait1Msec(500);

    ValueClaw = ClawOpenLimit;

    Drive(100, Backward, "SensorEncoderDrive", 300);

    ValueFourBar = FourBarFloor;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Tasks
//
// Below are the tasks that the robot will use to convert the human opperator's remote
// inputs into the robot's movements during the 2-minute driver control period.
//
/////////////////////////////////////////////////////////////////////////////////////////

task DriveMotorControl() //This task is used to allow the human opperator to control the speed and direction of the drive motors in driver control
{ //mode.
  int Neutral = 15;

  int InitialPower = 15; //The smallest power that the drive motors need in order to actaully get the robot moving.

  float TempScaleLeft;
  float TempScaleRight;

  float LeftJoystick; //The left joystick's y-axis value.
  float RightJoystick; //The right joystick's y-axis value.

  float LeftDriveMotors; //Create variables for the left and right side drive motors' speeds, so that they can be manipulated easily.
  float RightDriveMotors;

  while(true) //Continue to monitor the drive motors' speeds by using the joysticks on remote 1's values for the entire driver control period.
  {
    LeftJoystick = vexRT[Ch3]; //Update the joystick's values.
    RightJoystick = vexRT[Ch2];

    TempScaleLeft = LeftJoystick / 127;
    TempScaleRight = RightJoystick / 127;

    if(LeftJoystick > Neutral)
    {
      LeftDriveMotors = TempScaleLeft*TempScaleLeft*TempScaleLeft*TempScaleLeft*TempScaleLeft;
      LeftDriveMotors = (127-InitialPower) * LeftDriveMotors;
      LeftDriveMotors = InitialPower + LeftDriveMotors;
    }
    else if(LeftJoystick < -1 * Neutral)
    {
      LeftDriveMotors = TempScaleLeft*TempScaleLeft*TempScaleLeft*TempScaleLeft*TempScaleLeft;
      LeftDriveMotors = (127-InitialPower) * LeftDriveMotors;
      LeftDriveMotors = (-1*InitialPower) + LeftDriveMotors;
    }
    else
    {
      LeftDriveMotors = 0;
    }

    if(RightJoystick > Neutral)
    {
      RightDriveMotors = TempScaleRight*TempScaleRight*TempScaleRight*TempScaleRight*TempScaleRight;
      RightDriveMotors = (127-InitialPower) * RightDriveMotors;
      RightDriveMotors = InitialPower + RightDriveMotors;
    }
    else if(RightJoystick < -1 * Neutral)
    {
      RightDriveMotors = TempScaleRight*TempScaleRight*TempScaleRight*TempScaleRight*TempScaleRight;
      RightDriveMotors = (127-InitialPower) * RightDriveMotors;
      RightDriveMotors = (-1*InitialPower) + RightDriveMotors;
    }
    else
    {
      RightDriveMotors = 0;
    }

    if(vexRT[Btn5U] > 0 || vexRT[Btn5D] > 0 || vexRT[Btn6U] > 0 || vexRT[Btn6D] > 0)
    {
      LeftDriveMotors = LeftDriveMotors / 1.75;
      RightDriveMotors = RightDriveMotors / 1.75;
    }

    motor[MotorDriveLeft1] = LeftDriveMotors;
    motor[MotorDriveLeft2] = LeftDriveMotors;
    motor[MotorDriveRight1] = RightDriveMotors;
    motor[MotorDriveRight2] = RightDriveMotors;
  }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


task FourBarControl() //This task is used to allow the human operator to control the position of the four-bar in driver control mode.
{
  int Neutral = 15; //Set the variable "Neutral" to the highest number the joystick may reach while still not being pushed in any direction.
  bool First = true;
  int FourBarPosition = SensorValue[SensorPotFourBar]; //Create the variable "FourBarPosition" for the position the four-bar needs to maintain.
  int Difference;

  while(true) //Continue to monitor the four-bar's position by using the left joystick on remote 2's values for the entire driver control period.
  {
    Difference = FourBarPosition - SensorValue[SensorPotFourBar];

    if(vexRT[Ch3Xmtr2] > Neutral) //Otherwise if the left joystick on remote 2 is being pressed forwards...
	  {
	    if(vexRT[Btn8UXmtr2] > 0 || vexRT[Btn8LXmtr2] > 0 || vexRT[Btn8RXmtr2] > 0 || vexRT[Btn8DXmtr2] > 0)
	    {
	      if(SensorValue[SensorPotFourBar] < FourBarUpperLimit)
	      {
	        motor[MotorFourBarLeft] = vexRT[Ch3Xmtr2];
	        motor[MotorFourBarRight] = motor[MotorFourBarLeft];
	        motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	        motor[MotorFourBarRight2] = motor[MotorFourBarLeft];

	        FourBarPosition = SensorValue[SensorPotFourBar]; //and set the new position of the four-bar.
	      }

	      else
	      {
	        motor[MotorFourBarLeft] = (0.1 * (Difference - 130)) + 31;
	        motor[MotorFourBarRight] = motor[MotorFourBarLeft];
	        motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	        motor[MotorFourBarRight2] = motor[MotorFourBarLeft];
	      }
	    }

	    else if(SensorValue[SensorPotFourBar] < FourBarUpperLimit) //... and if the four-bar is not above it's upper limit...
	    {
	      motor[MotorFourBarLeft] = vexRT[Ch3Xmtr2] / 2 + 30; //... allow the four-bar to be raised, calculate it's speed,
	      motor[MotorFourBarRight] = motor[MotorFourBarLeft];
	      motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	      motor[MotorFourBarRight2] = motor[MotorFourBarLeft];

	      FourBarPosition = SensorValue[SensorPotFourBar]; //and set the new position of the four-bar.
	    }

	    else //... and otherwise assume that the four-bar is already above it's upper limit...
	    {
	      Difference = FourBarUpperLimit - SensorValue[SensorPotFourBar];

	      motor[MotorFourBarLeft] = (0.1 * (Difference - 130)) + 31; //... calculate the power of the
	      motor[MotorFourBarRight] = motor[MotorFourBarLeft]; //four-bar's motors based on how far off it is from where it needs to be.
	      motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	      motor[MotorFourBarRight2] = motor[MotorFourBarLeft];
	    }
	  }

	  else if(vexRT[Ch3Xmtr2] < -1 * Neutral) //Otherwise if the left joystick on remote 2 is being pressed backwards...
	  {
	    if(vexRT[Btn8UXmtr2] > 0 || vexRT[Btn8LXmtr2] > 0 || vexRT[Btn8RXmtr2] > 0 || vexRT[Btn8DXmtr2] > 0)
	    {
	      if(SensorValue[SensorPotFourBar] > FourBarFloor)
	      {
	        motor[MotorFourBarLeft] = vexRT[Ch3Xmtr2];
	        motor[MotorFourBarRight] = motor[MotorFourBarLeft];
	        motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	        motor[MotorFourBarRight2] = motor[MotorFourBarLeft];

	        FourBarPosition = SensorValue[SensorPotFourBar]; //and set the new position of the four-bar.
	      }

	      else
	      {
	        motor[MotorFourBarLeft] = (0.1 * (Difference - 130)) + 31;
	        motor[MotorFourBarRight] = motor[MotorFourBarLeft];
	        motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	        motor[MotorFourBarRight2] = motor[MotorFourBarLeft];
	      }
	    }

	    else if(SensorValue[SensorPotFourBar] > FourBarFloor) //... and if the four-bar is not below it's lower limit...
	    {
	      motor[MotorFourBarLeft] = vexRT[Ch3Xmtr2] / 7; //... allow the four-bar to be lowered, calculate it's speed,
	      motor[MotorFourBarRight] = motor[MotorFourBarLeft];
	      motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	      motor[MotorFourBarRight2] = motor[MotorFourBarLeft];

	      FourBarPosition = SensorValue[SensorPotFourBar]; //and set the new position of the four-bar.
	    }

	    else //... but the four-bar is already below it's lower limit...
	    {
	      motor[MotorFourBarLeft] = 0;
	      motor[MotorFourBarRight] = 0;
	      motor[MotorFourBarLeft2] = 0;
	      motor[MotorFourBarRight2] = 0;
	    }

	    if(SensorValue[SensorPotFourBar] < (FourBarFloor + FourBarBottomBaseGoal) / 2)
	    {
	      FourBarPosition = FourBarFloor;
	    }
	  }

	  else //Otherwise assume the left joystick on remote 2 is in the neutral position...
	  {
	    if(SensorValue[SensorPotFourBar] < FourBarPosition) //... and if the 4-bar is below the desired position...
	    {
	      //Stall = 25
        //Fastest Lift = 65
	      //(65-25) / (1000-0) = 0.04
	      motor[MotorFourBarLeft] = (0.15 * (Difference - 50)) + 20; //... calculate the power of the
	      motor[MotorFourBarRight] = motor[MotorFourBarLeft]; //4-bar's motors based on how far off it is from where it needs to be.
	      motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	      motor[MotorFourBarRight2] = motor[MotorFourBarLeft];
	    }

	    else if(SensorValue[SensorPotFourBar] > FourBarPosition) //... and otherwise if the four bar is above the desired position...
	    {
	      if(SensorValue[SensorPotFourBar] < (FourBarFloor + FourBarBottomBaseGoal) / 2)
	      {
	        motor[MotorFourBarLeft] = -10;
	        motor[MotorFourBarRight] = -10;
	        motor[MotorFourBarLeft2] = -10;
	        motor[MotorFourBarRight2] = -10;

	        FourBarPosition = FourBarFloor;
	      }

	      else
	      {
	        //Stall = 25
          //Fastest Lower = 5
	        //(5-25) / (1000-0) = -0.02
	        motor[MotorFourBarLeft] = (0.1 * (Difference - 50)) + 25; //... calculate the power of the 4-bar's motors based on how far off it is from
	        motor[MotorFourBarRight] = motor[MotorFourBarLeft]; //where it needs to be.
	        motor[MotorFourBarLeft2] = motor[MotorFourBarLeft];
	        motor[MotorFourBarRight2] = motor[MotorFourBarLeft];
	      }
	    }
	  }

	  if(vexRT[Btn5UXmtr2] > 0) //If the "U" button on the "5" section of remote 1 is pressed...
	  {
      if(First == true) //... and if this is the first time the button has been pressed since the last time it was released...
      {
        First = false; //... set "First" to false, since the button was just pressed and has not been released yet.

        if(FourBarPosition < FourBarBottomBaseGoal) //... and if the 4-bar is currently on the floor...
        {
          FourBarPosition = FourBarBottomBaseGoal; //... set the position of the 4-bar to be ready to de-score from a moveable weighted base.
        }
        else if(FourBarPosition >= FourBarBottomBaseGoal && FourBarPosition < FourBarTopBaseGoal) //... and otherwise if the 4-bar is in position to de-score from a moveable weighted base...
        {
          FourBarPosition = FourBarTopBaseGoal; //... set the position of the 4-bar to be ready to score on a moveable weighted base.
        }
        else if(FourBarPosition >= FourBarTopBaseGoal && FourBarPosition < FourBarBottomWallGoal) //... and otherwise if the 4-bar is in position to score on a moveable weighted base...
        {
          FourBarPosition = FourBarBottomWallGoal; //... set the position of the 4-bar to be ready to de-score from a wall goal.
        }
        else if(FourBarPosition >= FourBarBottomWallGoal) //... and otherwise if the 4-bar is in position to de-score from a wall goal.
        {
          FourBarPosition = FourBarTopWallGoal; //... set the position of the 4-bar to be ready to score on a wall goal.
        }
      }
    }

    else if(vexRT[Btn5DXmtr2] > 0) //Otherwise if the "D" button on the "5" section of remote 1 is pressed...
    {
      if(First == true) //... and if this is the first time the button has been pressed since the last time it was released...
      {
        First = false; //... set "First" to false, since the button was just pressed and has not been released yet.

        if(FourBarPosition > FourBarTopWallGoal) //... and if the 4-bar is currently higher than the top of a wall goal...
        {
          FourBarPosition = FourBarTopWallGoal; //... set the position of the 4-bar to be ready to score on a wall goal.
        }
        else if(FourBarPosition > FourBarBottomWallGoal && FourBarPosition <= FourBarTopWallGoal) //... and otherwise if the 4-bar is ready to score on a wall goal...
        {
          FourBarPosition = FourBarBottomWallGoal; //... set the position of the 4-bar to be ready to de-score from a wall goal.
        }
        else if(FourBarPosition > FourBarTopBaseGoal && FourBarPosition <= FourBarBottomWallGoal) //... and otherwise if the 4-bar is ready to de-score from a wall goal...
        {
          FourBarPosition = FourBarTopBaseGoal; //... set the position of the 4-bar to be ready to score on a moveable weighted base.
        }
        else if(FourBarPosition > FourBarBottomBaseGoal && FourBarPosition <= FourBarTopBaseGoal) //... and otherwise if the 4-bar is ready to score on a moveable weighted base...
        {
          FourBarPosition = FourBarBottomBaseGoal; //... set the position of the 4-bar to be ready to de-score from a moveable weighted base.
        }
        else if(FourBarPosition > FourBarFloor && FourBarPosition <= FourBarBottomBaseGoal) //... and otherwise if the 4-bar is ready to de-score from a moveable weighted base...
        {
          FourBarPosition = FourBarFloor; //... set the position of the 4-bar to be on the floor, ready to pick up a tube or stack of tubes.
        }
      }
    }

    else //Otherwise assume that neither the "U" or "D" buttons on the "5" section of remote 1 are being pressed...
    {
      First = true; //... and set "First" to true, since the buttons have been released.
    }
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task ClawControl()
{
  int Neutral = 25;

  float Difference;

  int Middle = ClawOpenLimit + ClawClosedLimit;
  Middle = Middle / 2;

  bool First = true;

  ValueClaw = SensorValue[SensorPotClaw]; //Set the desired position of the claw to it's current position.

  while(true)
  {
    Difference = ValueClaw - SensorValue[SensorPotClaw];

	  if(vexRT[Ch2Xmtr2] > Neutral) //If the right joystick on remote 2 is being pushed forwards...
    {
      if(SensorValue[SensorPotClaw] < ClawClosedLimit) //... and if the claw is not closed all the way...
      {
        motor[MotorClaw] = vexRT[Ch2Xmtr2]; //... allow the claw to be opened/closed at the desired speed based on the y-axis movement of the right
        //joystick on remote 2.
        ValueClaw = SensorValue[SensorPotClaw]; //... and update the desired position of the claw.
      }
      else
      {
        motor[MotorClaw] = 0;
        ValueClaw = ClawClosedLimit;
      }
    }

    else if(vexRT[Ch2Xmtr2] < -1 * Neutral) //Otherwise if the right joystick is being pushed backwards...
    {
      if(SensorValue[SensorPotClaw] > ClawOpenLimit) //... and if the claw is not opened all the way...
      {
        motor[MotorClaw] = vexRT[Ch2Xmtr2]; //... allow the claw to be opened/closed at the desired speed based on the y-axis movement of the right
        //joystick on remote 2.
        ValueClaw = SensorValue[SensorPotClaw]; //... and update the desired position of the claw.
      }
      else
      {
        motor[MotorClaw] = 0;
        ValueClaw = ClawOpenLimit;
      }
    }

	  else //Otherwise assume that the right joystick on remote 2 is not being pushed forwards or backwards...
	  {
	    motor[MotorClaw] = (0.23 * (Difference - 0)) + 25; //... and start monitoring the position of the claw.
	    //(y1-y2) / (x1-x2) = m, MotorPower = (m * (Difference - y2)) + x2.
	  }

	  if(vexRT[Btn6UXmtr2] > 0 || vexRT[Btn6DXmtr2] > 0) //If the "U" or "D" buttons on the "6" side of remote 2 are pressed...
	  {
	    if(First == true) //... and if this is the first time that the buttons have been pressed since they were last released...
	    {
	      First = false; //... set "First" to false, since the buttons were just pressed, and have not been released yet.

	      if(SensorValue[SensorPotClaw] <= Middle) //... and if the claw is open...
	      {
	        ValueClaw = ClawClosedLimit; //... set the desired position of the claw to be closed.
	      }

	      else if(SensorValue[SensorPotClaw] > Middle) //... and otherwise if the claw is closed...
	      {
	        ValueClaw = ClawOpenLimit; //... set the desired position of the claw to be open.
	      }
	    }
	  }

	  else if(vexRT[Btn6UXmtr2] <= 0 && vexRT[Btn6DXmtr2] <= 0) //Otherwise if both the "U" and "D" buttons on the "6" side of remote 2 are
	  { //released...
	    First = true; //... set "First" equal to true, since the buttons have just been released.
	  }
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


task DescoringForkControl()
{
  const int Up = 1;
  const int Down = 2;
  int Position = 1;

  while(true)
  {
	  if(vexRT[Btn8UXmtr2] > 0 || vexRT[Btn8LXmtr2] > 0 || vexRT[Btn8RXmtr2] > 0) //If the "U", "L" or "R" buttons on the "8" side of remote 2 are being pressed...
	  {
	    motor[MotorDescoringFork] = 127;
	    Position = Up;
	  }
	  else if(vexRT[Btn8DXmtr2] > 0) //Otherwise if the "D" button on the "8" side of remote 2 is being pressed...
	  {
	    motor[MotorDescoringFork] = -127;
	    Position = Down;
	  }
	  else //Otherwise assume that none of the buttons on the "8" side of remote 2 are being pressed...
	  {
	    //And hold the position the descoring fork is currently in.

	    if(Position == Up)
	    {
	      motor[MotorDescoringFork] = 20;
	    }
	    else
	    {
	      motor[MotorDescoringFork] = -20;
	    }
	  }
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

  StopTask(FourBar);
  StopTask(Claw);

  StartTask(DriveMotorControl);
  StartTask(FourBarControl);
  StartTask(ClawControl);
  StartTask(DescoringForkControl);

	while (true)
	{
	  // This is the main execution loop for the user control program. Each time through the loop
	  // your program should update motor + servo values based on feedback from the joysticks.

	  // .....................................................................................
	  // Insert user code here. This is where you use the joystick values to update your motors, etc.
	  // .....................................................................................
	}
}
