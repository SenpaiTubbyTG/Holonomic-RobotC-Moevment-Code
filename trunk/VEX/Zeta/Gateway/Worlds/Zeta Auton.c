#pragma config(UART_Usage, UART2, VEX_2x16_LCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl6,  startAuton,     sensorTouch)
#pragma config(Sensor, dgtl7,  encoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  solenoidL,      sensorDigitalOut)
#pragma config(Sensor, dgtl10, solenoidR,      sensorDigitalOut)
#pragma config(Sensor, dgtl11, encoderR,       sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           collectorL,    tmotorServoContinuousRotation, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           frontL,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           frontL2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           backL,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           backL2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           frontR,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           frontR2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           backR,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           backR2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          collectorR,    tmotorServoContinuousRotation, openLoop, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


void setSuckSpeed(int speed, int duration)   {
  motor[collectorL] = motor[collectorR] = speed;
  wait1Msec(duration);
  motor[collectorL] = motor[collectorR] = 0;
}//END void

void drive_forward_msec(int speed, int duration) {
  motor[frontL] = motor[frontL2] = motor[backL] = motor[backL2] = motor[frontR] = motor[frontR2] = motor[backR] = motor[backR2] = speed;
  wait1Msec(duration);
  motor[frontL] = motor[frontL2] = motor[backL] = motor[backL2] = motor[frontR] = motor[frontR2] = motor[backR] = motor[backR2] = 0;
}//END void

void pre_auton() {
}//END void //

task autonomous() {
  wait1Msec(200);
  SensorValue[solenoidL] = SensorValue[solenoidR] = 1;  // raise lift
  while(SensorValue[startAuton] == 0);                  // wait until touch sensor startauton is pressed

  drive_forward_msec(-127,1150);                        // drive backwards at full power for 1.15 seconds

  wait1Msec(1000);                                      // wait 1 second
  setSuckSpeed(100,3500);                               // collector scores at 100 speed for 3.5 seconds

  drive_forward_msec(127,500);                          // drive forward at full power for 0.5 seconds

  SensorValue[solenoidL] = SensorValue[solenoidR] = 0;  // lowers lift

  drive_forward_msec(127,500);                          // drive forward at full power for 0.5 seconds (will end up back in starting square)

  while(SensorValue[startAuton] == 0);                  // wait until touch sensor startauton is pressed

  drive_forward_msec(-127,350);                         // drive backwards at full power for 0.35 seconds

  drive_forward_msec(127,70);                           // drive forward at full power for 0.07 seconds

  setSuckSpeed(100,3000);                               // collector scores at 100 speed for 3.0 seconds

  drive_forward_msec(127,400);                          // drive forward at full power for 0.4 seconds

}//end task autonomous
