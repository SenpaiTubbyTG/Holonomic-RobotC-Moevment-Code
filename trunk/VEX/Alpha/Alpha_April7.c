#pragma config(Sensor, in1,    PotArm,              sensorPotentiometer)
#pragma config(Motor,  port1,           ArmLL,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port2,           DriveLF,     tmotorNormal, openLoop)
#pragma config(Motor,  port3,           DriveLB,      tmotorNormal, openLoop)
#pragma config(Motor,  port4,           DriveRF,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port5,           DriveRB,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           ArmLU,      tmotorNormal, openLoop)
#pragma config(Motor,  port7,           ArmRU,     tmotorNormal, openLoop)
#pragma config(Motor,  port8,           collector1,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           collector2,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port10,          ArmRL,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#define FULL 127
#include "alpha_lib.c" //Main Funtion Library
//#include "PIDController.c"
#include "PID Test.c"
//Standard Lock////////
int arm_grounded;
int low_descore;
int low_lock;
int high_descore;
int high_lock;

/******ARM PID*****************************************************************/
PIDController arm; //initializes PID controller
//PID constants
int goal_value = 1000;
int k_P = 1;
int k_I = 0;
int k_D = 0;

bool PID_arm = false; //arm PID enabled flag

void pre_auton() {
    /*Standard Arm:
    arm_grounded = SensorValue[PotArm];       // sets ground point           (0 inches)
    low_descore = arm_grounded + 1556 - 1247; // sets low descore arm point  (4.5 inches)
    low_lock = arm_grounded + 2326 - 1247;    //...lowgoal                   (15 inches)
    high_descore = arm_grounded + 1879- 1247; //...high descore              (x inches)
    high_lock = arm_grounded + 2599 - 1247;   // ...high goal                (18.5 inches)
     */
    //ARM PID:
    init(arm, PotArm, port4);
    setSetpoint(arm, goal_value);
    setPIDs(arm, k_P, k_I, k_D);
    enable(arm);
}

task autonomous() {
}

task usercontrol() {
    pre_auton();
    int goal_lock = 0;
    //0 for unlocked, -1 for low gal, 1 for high goal
    //calibration for potentiometer setting the arm
    /*int low_lock_point = SensorValue[in1] + 703;
    //low goal potentiometer reading
    //sets the low lock point based on the starting potentiometer point int high_lock_point = SensorValue[in1] + 1000;
    //high goal potentiometer reading
    //end calibrarion*/

    while (true) {
        /*******DRIVE******************************************************************/
        /* Original drive code, basic, no input scaling
         * motor[frontLeft] = motor[backLeft] = vexRT[Ch3];
                motor[frontRight] = motor[backRight] = vexRT[Ch2];*/

        //Drive function with input scaling, disabled by default
        driveTank(vexRT[Ch3], vexRT[Ch2], false, false);
        /*******ARM********************************************************************/

        /*  if(vexRT[Btn7L] == 1)//auto button close loop
            {
                goal_lock = -1;   //sets to low lock
            }
            else if(vexRT[Btn7U] == 1) {
                goal_lock = 1;	//sets to high lock
            }
            else if(vexRT[Btn7D] == 1) {// descore/ score on low goal...
                goal_lock = 2;
            }

            if(goal_lock == -1)
                lock(low_lock); //brings to low lock point
            else if(goal_lock == 1)
                lock(high_lock);//moves arm to high lock point

            //NEW STUFF TAKE THIS OUT IF IT DOESNT WORK
            else if (goal_lock == 2)
                lock(low_descore);//moves arm to descore lock point
            else if(goal_lock == 3)
                lock(high_descore);
            //------------------

            //Manual_Arm//
            if(vexRT[Ch3] < 15 && vexRT[Ch3] > -15){//Trim, if stick is between 15 & negative 15 motors equal 0.
            setArmSpeed(0);
            }
            else{//motors = stick angle
            setArmSpeed(vexRT[Ch3]);
            }

             Original arm code
            motor[ArmLU] = motor[ArmLL] = motor[ArmRU] = motor[ArmRL] =
                (vexRT[Btn6D] - vexRT[Btn6U]) * FULL;
            motor[collector1] = motor[collector2] = (vexRT[Btn5U] - vexRT[Btn5D]) * FULL;
         */
        //PID ARM//
        if (vexRT[Btn7L] == 1) {
            PID_arm = true;
            setSetpoint(arm, low_lock);
        } else if
            (vexRT[Btn7U] == 1) {
            PID_arm = true;
            setSetpoint(arm, low_descore);
        } else if
            (vexRT[Btn7R] == 1) {
            PID_arm = true;
            setSetpoint(arm, high_descore);
        } else if
            (vexRT[Btn7D] == 1) {
            PID_arm = true;
            setSetpoint(arm, high_lock);
        }

        if (PID_arm) {
            setArmSpeed(calculatePID(arm));
        }
    }
}
