#pragma config(Sensor, in1,    armPot,              sensorPotentiometer)
#pragma config(Sensor, in2,    clawPot,             sensorPotentiometer)
#pragma config(Sensor, in3,    lineFollower,        sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightEnc,            sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,             sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  sonar,               sensorSONAR_cm)
#pragma config(Motor,  port1,           arm,           tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port2,           right,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           left,          tmotorNormal, openLoop)
#pragma config(Motor,  port6,           right2,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           left2,         tmotorNormal, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorNormal, openLoop)
#pragma config(Motor,  port10,          arm2,          tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void pre_auton()
{
	SensorValue[armPot] = 0;
	SensorValue[clawPot] = 0;
	SensorValue[rightEnc] = 0;
	SensorValue[leftEnc] = 0;
}

//Variables for program to run

//variables for positions of the potentiometers
int goal_high_high = 3289;
int goal_high_low = 2900;
int goal_low_high = 3006;
int goal_low_low = 2470;
int floor_pos = 2220;
int claw_open = 1348;
int claw_closed = 1750;
int safety_time = 4;

//variables dealing with the dimensions of robot.
int robot_width = 26;//width of base of robot in cm.

/*
MoveRobot moves the robot either forward or backwards.
Ticks is the number of ticks to move the robot forward by. Enter 0 to disable ticks.
Time is how long the robot will run if encoders are disabled. Enter 0 to disable time.
If time and ticks are both disabled, then the robot will run forward at the specified speed without end.
*/
void MoveRobot (int power, int time, int ticks)
{
  time1[T2] = 0;
  if (ticks > 0){
    while((abs(SensorValue[rightEnc]) + abs(SensorValue[leftEnc]))/2 < ticks && time1[T2] < time*2){
      motor[left] = power;
      motor[left2] = power;
      motor[right] = power;
      motor[right2] = power;
    }
  }
  else if(time > 0){
    time1[T1] = 0;
    while(time1[T1] < time){
      motor[left] = power;
      motor[left2] = power;
      motor[right] = power;
      motor[right2] = power;
    }
  }
  else{
    motor[left] = power;
    motor[left2] = power;
    motor[right] = power;
    motor[right2] = power;
  }
}

/*
MoveArm moves the arm to a certain position that is specified at the power that is specified.
The program doesnt care what position the arm starts at and will move to the specified position.
*/
void MoveArm (int power, int pos){
  do{
    if (SensorValue[armPot] < pos){
      motor[arm] = power;
      motor[arm2] = power;
    }
    else if(SensorValue[armPot] > pos){
      motor[arm] = -power;
      motor[arm2] = -power;
    }
    else{
      motor[arm] = 15;
      motor[arm2] = 15;
    }
  }while(SensorValue[armPot] != pos);
}

/*
MoveClaw opens or closes the claw to match the specified position at the specified power.
*/
void MoveClaw (int power, int pos){
  do{
    if (SensorValue[clawPot] < pos){
      motor[claw] = power;
    }
    else if(SensorValue[clawPot] > pos){
      motor[claw] = -power;
    }
    else{
      motor[claw] = 0;
    }
  }while(SensorValue[clawPot] != pos);
  motor[claw] = 0;
}

/*
PivotTurn turns the robot in place at the specified power.
The disabling of time and ticks works the same way as in the MoveRobot function.
Positive power turns left and negative power turns right. THINK RADIANS!!!
*/
void PivotTurn (int power, int time, int ticks){
  if (ticks > 0){
    while((abs(SensorValue[rightEnc]) + abs(SensorValue[leftEnc]))/2 < ticks && time1[T2] < time*2){
      motor[left] = -power;
      motor[left2] = -power;
      motor[right] = power;
      motor[right2] = power;
    }
  }
  else if(time > 0){
    time1[T1] = 0;
    while(time1[T1] < time){
      motor[left] = -power;
      motor[left2] = -power;
      motor[right] = power;
      motor[right2] = power;
    }
  }
  else{
    motor[left] = -power;
    motor[left2] = -power;
    motor[right] = power;
    motor[right2] = power;
  }
}

/*
VeerTurn has the robot move forward while veering to one side or the other at a specified speed.
The speed is for the speed of the center of the robot. Radius should be entered in cm.
Positive radius turns left, negative radius turns right.
*/
void VeerTurn (int power, int radius, int ticks, int time){
  int right = 0;
  int left = 0;

  right = (power*(radius + (robot_width/2)))/radius;
  left = (power*(radius - (robot_width/2)))/radius;

  if(ticks > 0){
    while((abs(SensorValue[rightEnc]) + abs(SensorValue[leftEnc]))/2 < ticks && time1[T2] < time*2){
      motor[right] = right;
      motor[right2] = right;
      motor[left] = left;
      motor[left2] = left;
    }
  }
  else if(time > 0){
    time1[T1] = 0;
    while(time1[T1] < time){
      motor[right] = right;
      motor[right2] = right;
      motor[left] = left;
      motor[left2] = left;
    }
  }
  else{
    motor[right] = right;
    motor[right2] = right;
    motor[left] = left;
    motor[left2] = left;
  }
}

//Stop is a function to stop all used motors for use in both autonomous and tele-op modes.
void Stop(){
  motor[arm] = 0;
  motor[arm2] = 0;
  motor[claw] = 0;
  motor[right] = 0;
  motor[right2] = 0;
  motor[left] = 0;
  motor[left2] = 0;
}

task autonomous()
{
	/*original autonomous program.
	MoveRobot(-110,200,1.0);// robot moves back hpefully dropping the preload
	wait1Msec(1500);
	MoveRobot(110,400,2.0);//moves forward
	MoveClaw(100,claw_closed);//closes over preload
	MoveRobot(110,900,4.0);//go over goal
	MoveArm(111, goal_high_high);//move arm up
	MoveRobot(110,900, 4.0);//go over goal?
	MoveArm(111, goal_high_low);
	MoveArm(60, goal_high_low+60);
	MoveClaw(100,claw_open);
  */

  //All claw functions will remain commented out until claw pot is fixed.
  MoveRobot(64,2,45);//move robot forward to go after first stack
  //MoveClaw(128,claw_closed);//close claw on stck with full power.
  PivotTurn(-64,1,12);//Turn right to face goal
  MoveArm(64, goal_low_high);//Raises arm to above the low goal's top.
  MoveRobot(64,3,110);//move forward to goal
  wait1Msec(10);
  MoveRobot(-32, 1, 6);//move robot backwards to line up claw with goal
  MoveArm(10,goal_low_low);//lowers arm to be on base of low goal.
  wait1Msec(10);
  //MoveClaw(128, claw_open);//opens claw to release hoops.
  MoveRobot(-32,5,32);//move robot away from goal.
  //MoveClaw(32,claw_closed);//close the claw so it doesn't get caught on the body when lowering arm
  MoveArm(10,floor_pos);//move the arm back to the floor position
  PivotTurn(-64,3,28);//Turn right to face away from goal.
  MoveRobot(128,4,180);//Run forward to knock down opponent's stack.

}

task usercontrol()
{
	while (true)
	{
	  UserControlCodePlaceholderForTesting();
	}
}
