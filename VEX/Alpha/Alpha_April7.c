#pragma config(Sensor, in5,    PotArm,              sensorPotentiometer)
#pragma config(Motor,  port1,           ArmLL,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port2,           DriveLF,     tmotorNormal, openLoop)
#pragma config(Motor,  port3,           DriveLB,      tmotorNormal, openLoop)
#pragma config(Motor,  port4,           DriveRF,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port5,           DriveRB,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           ArmLU,      tmotorNormal, openLoop)
#pragma config(Motor,  port7,           ArmRU,     tmotorNormal, openLoop)
#pragma config(Motor,  port8,           collector1,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           collector2,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port10,          ArmRL,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)b

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "alpha_lib.c" //Main Funtion Library
#include "PIDController.c
//Standard Lock////////
int arm_grounded;
int low_descore;
int low_lock;
int high_descore;
int high_lock;
int DriveMode;

/******ARM PID*****************************************************************/
PIDController arm;

int startpoint = 0;
int goal_value = startpoint;
int change = -1000;
int k_P = 10;
int k_I = 0;
int k_D = 0;

bool PID_arm = false; //arm PID enabled flag

void pre_auton() {
    //Standard Arm:
    arm_grounded = SensorValue[PotArm];       // sets ground point           (0 inches)
    low_descore = arm_grounded + 1556 - 1247; // sets low descore arm point  (4.5 inches)
    low_lock = arm_grounded + 2326 - 1247;    //...lowgoal                   (15 inches)
    high_descore = arm_grounded + 1879- 1247; //...high descore              (x inches)
    high_lock = arm_grounded + 2599 - 1247;   // ...high goal                (18.5 inches)
    DriveMode=0;

    startpoint = SensorValue[PotArm];
    goal_value = startpoint + change;
    //PID:
    init(arm);
    setPIDs(arm, k_P, k_I, k_D);
    setSetpoint(arm, goal_value);
    enable(arm);
}

task autonomous() {
}

task usercontrol() {
    pre_auton();
    int goal_lock = 0;
    //0 for unlocked, -1 for low goal, 1 for high goal
    //calibration for potentiometer setting the arm
    /*int low_lock_point = SensorValue[in1] + 703;
    //low goal potentiometer reading
    //sets the low lock point based on the starting potentiometer point int high_lock_point = SensorValue[in1] + 1000;
    //high goal potentiometer reading
    //end calibrarion*/

    while (true) {
/*******DRIVE******************************************************************/
        /* Original drive code, basic, no input scaling
          motor[DriveLB] = motor[DriveLF] = checkDeadZone(vexRT[Ch3]);
          motor[DriveRB] = motor[DriveRF] = checkDeadZone(vexRT[Ch2]);*/

        //Allows buttons to change drive mode (scaling function)
        if(vexRT[Btn8U] == 1)// no scaling
            {
                DriveMode = 0;
            }
        if(vexRT[Btn8R] == 1)//Squaring function, concave up
            {
                DriveMode = 1;
            }
        if(vexRT[Btn8D] == 1)//arcsin function, concave up
            {
                DriveMode = 2;
            }
        
        if(vexRT[Btn8L] == 1)//Sets to arctan(x^2) function, concave down
            {
                DriveMode = 3;
            }
//parameters (left input,right input,scaling (t/f),rate filter,(t/f),DriveMode)
//rate filter disabled by default as constant has not been determined
        driveTank(vexRT[Ch3], vexRT[Ch2], true, false,DriveMode)
/*******ARM********************************************************************/

        // Manual arm code
        if(abs(vexRT[Btn5U])==1||abs(vexRT[btn5D])==1){
            PID_arm=false;
            motor[ArmLU] = motor[ArmLL] = motor[ArmRU] = motor[ArmRL] =
                (vexRT[Btn5D] - vexRT[Btn5U]) * FULL;
        }
        //PID ARM
        if (vexRT[Btn7L] == 1) { //sets arm to low score
            PID_arm = true;
            setSetpoint(arm, low_lock);
        } else if(vexRT[Btn7U] == 1) { //sets arm to low descore
            PID_arm = true;
            setSetpoint(arm, low_descore);
        } else if(vexRT[Btn7R] == 1) { //sets arm to high descore
            PID_arm = true;
            setSetpoint(arm, high_descore);
        } else if(vexRT[Btn7D] == 1) { //sets arm to high score
            PID_arm = true;
            setSetpoint(arm, high_lock);
        }

        if (PID_arm) {
            setArmSpeed(calculatePID(arm, SensorValue[PotArm]);
        }
/*******COLLECTOR**************************************************************/
        motor[collector1] = motor[collector2] = (vexRT[Btn6U] - vexRT[Btn6D]) * FULL;
    }
}
