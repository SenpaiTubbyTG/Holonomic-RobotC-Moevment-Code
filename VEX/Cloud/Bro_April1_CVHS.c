#pragma config(Sensor, in1,    armPot,              sensorPotentiometer)
#pragma config(Sensor, in2,    clawPot,             sensorPotentiometer)
#pragma config(Sensor, in3,    lineFollower,        sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightEnc,            sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,             sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  choice,              sensorTouch)
#pragma config(Motor,  port1,           backleft,      tmotorNormal, openLoop)
#pragma config(Motor,  port2,           left,          tmotorNormal, openLoop)
#pragma config(Motor,  port3,           armright1,     tmotorNormal, openLoop)
#pragma config(Motor,  port4,           armleft1,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port5,           claw,          tmotorNormal, openLoop)
#pragma config(Motor,  port7,           armleft2,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           armright2,     tmotorNormal, openLoop)
#pragma config(Motor,  port9,           right,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port10,          backright,     tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void pre_auton()
{

}

/****************************************************************************************DRIVING FUNCTIONS*****************************************************************************************/
int leftDrivePower, rightDrivePower, x, y;//drivetrain variables

void setDriveMotors(){
  motor[left] = leftDrivePower;
  motor[backleft] = leftDrivePower;
  motor[right] = rightDrivePower;
  motor[backright] = rightDrivePower;
}

void stopDrive(){
  rightDrivePower = leftDrivePower = 0;
  setDriveMotors();
}

void driveTank(int left, int right, bool square){
  if(square){
    if(left!=0){
      leftDrivePower = ((left*left)/128)*(left/abs(left));
    }
    else{
      leftDrivePower = 0;
    }

    if(right!=0){
      rightDrivePower = ((right*right)/128)*(right/abs(right));
    }
    else{
      rightDrivePower = 0;
    }
  }
  else{
    leftDrivePower = left;
    rightDrivePower = right;
  }

  setDriveMotors();
}

void driveArcade(int power, int turn, bool square){
  if(square){
    if(power != 0){
      y = ((power*power)/128)*(power/abs(power));
    }
    else{
      y = 0;
    }

    if(turn!=0){
      x = ((turn*turn)/128)*(turn/abs(turn));
    }
    else{
      x = 0;
    }
  }
  else{
    y = power;
    x = turn;
  }

  leftDrivePower = y+x;
  rightDrivePower = y-x;

  setDriveMotors();
}

/*******************************************************************************************Arm & Claw Code****************************************************************************************/
int armPower, clawPower, armPosition, clawPosition, armTolerance, clawTolerance;//arm and claw tolerance to be set

void setArmMotors(){
  motor[armleft1] = motor[armleft2] = motor[armright1] = motor[armright2] = armPower;
  motor[claw] = clawPower;
}

void armMove(int aPower, int cPower, int armPos, int clawPos){//basic controls right now. Should be replaced with a proper PID loop control on the arm position when the programmer isn't tired.
  if((SensorValue[armPot] <= (armPos - armTolerance))||(SensorValue[armPot] >= (armPos + armTolerance))){
    armPower = ((armPos - armPot)/armPos) * 128;
  }
  else{
    armPower = 0;
  }

  if((SensorValue[clawPot] <= (clawPos - clawTolerance))||(SensorValue[clawPot] >= (clawPos + clawTolerance))){
    armPower = ((clawPos - clawPot)/clawPos) * 128;
  }
  else{
    armPower = 0;
  }

  setArmMotors();
}

void armMove(int aPower, int cPower){
  armPower = aPower;
  clawPower = cPower;
  setArmMotors();
}

/*****************************************************************************************Competition Code*****************************************************************************************/
int armInput, clawInput;
task autonomous()
{
  time1[T1] = 0;
  while(time1[T1] < 1500){
    driveArcade(128,0,false);
  }
  stopDrive();
}

task usercontrol()
{

	while (true)
	{
    driveArcade(vexRT[Ch3],vexRT[Ch4],false);

    if (vexRT[Btn6U] != 0 ||vexRT[Btn5U] != 0 )
      clawInput = 110;
    else if(vexRT[Btn6D] != 0 || vexRT[Btn5D] != 0)
      clawInput = -63;
    else
      clawInput = 0;

    armMove(vexRT[Ch2], clawInput);
	}
}
