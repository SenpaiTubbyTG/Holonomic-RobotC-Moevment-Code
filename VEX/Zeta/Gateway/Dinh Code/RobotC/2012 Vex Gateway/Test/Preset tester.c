#pragma config(Sensor, in1,    pot,                 sensorPotentiometer)
#pragma config(Sensor, in2,    ppot,                sensorPotentiometer)
#pragma config(Sensor, dgtl1,  ,                    sensorTouch)
#pragma config(Sensor, dgtl2,  ncoderL,             sensorNone)
#pragma config(Sensor, dgtl3,  touchl,              sensorTouch)
#pragma config(Sensor, dgtl4,  ncoderR,             sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchh,              sensorTouch)
#pragma config(Sensor, dgtl9,  arm,                 sensorQuadEncoder)
#pragma config(Sensor, dgtl12, TouchGoal,           sensorTouch)
#pragma config(Motor,  port2,           DriveLF,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           DriveRF,       tmotorNormal, openLoop)
#pragma config(Motor,  port4,           DriveRB,       tmotorNormal, openLoop)
#pragma config(Motor,  port5,           DriveLB,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           lift1,         tmotorNormal, openLoop)
#pragma config(Motor,  port7,           lift2,         tmotorNormal, openLoop)
#pragma config(Motor,  port8,           lift3,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port9,           lift4,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port10,          Claw,          tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(200)
/*
////////////////////////////////motor ports and explantion not code/////////////////////////////////////////////////////////
// Motor[drivetrain]                                                       \\
//backR = A<---power expander, port 4                                       \\
//backL = B,---power expander, port 5                                        \\
//frontR = port3                                                              \\
//frontL2 = port 2                                                             \\
//because my encoders were not working I had to name them dgtl...               \\
//left encoder = dgtl2 and right encoder = dgtl 4                                \\
//The Finders are just to make looking for the auton and teleop easier            \\
// In theory this program should score 20 points in auton and have a presetn teleop\\
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "Lance_Function_Library_v1.0.c" //Funtion Library

/*
Pot values NOT CODE
arm_grounded = 1400 or 1250
descore_lock_point = 1748 - 1250(1400) = 347
low_lock_point = 2550 - arm grounded = 1150
descore_high_point =
high_lock_point = 2775 - arm_grounded = 1475

*/

int arm_grounded;
int descore_low_point;
int low_lock_point;
int descore_high_point;
int high_lock_point;

void pre_auton()
{
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
  arm_grounded = SensorValue[arm];
  //////////////////////////////////////////////////////////////////////////////////////////////
  descore_low_point = 0;    low_lock_point = 500; //low goal potentiometer reading
  //sets the low lock point based on the starting potentiometer point



  /////////////////////////////////////
  descore_high_point = 250;//<<<<---------------------------------------------------run debugger in tele op and see what this value is,
  //put that value where the XXXXX's are
  ////////////////////////////////////////



  high_lock_point = 365; //high goal potentiometer reading
  /////////////////////////////////////////////////////////////////////

  //arm_grounded += 250;
}

task autonomous()
{





}// task main


//lock(low_lock_point); //<-------------------------------------pot code


//lock(low_lock_point); //<-------------------------------------pot code


//USER CONTROL/////////////////////////////////////////////////////////////////
task usercontrol()
{
  pre_auton();
  int goal_lock = 0;  //0 for unlocked, -1 for low gal, 1 for high goal
  //calibration for potentiometer setting the arm
  /*int low_lock_point = SensorValue[in1] + 703; //low goal potentiometer reading
  //sets the low lock point based on the starting potentiometer point
  int high_lock_point = SensorValue[in1] + 1000; //high goal potentiometer reading*/
  //end calibrarion


  while(true)
  {
    //Arm/////////////////////////////////////////////////////////////////////////
    if(vexRT[Btn7L] == 1)//auto button close loop
    {
      goal_lock = -1;   //sets to low lock
    }
    else if(vexRT[Btn7U] == 1) {
      goal_lock = 1;	//sets to high lock
    }
    else if(vexRT[Btn7D] == 1) {// descore/ score on low goal...
        goal_lock = 2;
    }
    else if(vexRT[Btn7R] == 1) {//same as 7D...
        goal_lock = 2;
    }


    if(goal_lock == -1)
      lock(low_lock_point); //brings to low lock point
    else if(goal_lock == 1)
      lock(high_lock_point);//moves arm to high lock point
    ///////////////////////////////////////////////////////////////NEW STUFF TAKE THIS OUT IF IT DOESNT WORK
    else if (goal_lock == 2)
      lock(descore_low_point);//moves arm to descore lock point
    else if(goal_lock == 3)
      lock(descore_high_point);
    //////////////////////////////////////////////////////////////


    //Finder: Arm control
    switch(vexRT[Btn5U] - vexRT[Btn5D]) //manual arm control
    {
    case  1:
      if(SensorValue[touchh] == 0) {
        motor[Lift1] = -127;
        motor[Lift2] = -127;
        motor[Lift3] = -127;
        motor[lift4] = -127;
        goal_lock = 0;  //unlocks arm
        } else {
        motor[lift1] = 0;
        motor[lift2] = 0;
        motor[lift3] = 0;
        motor[lift4] = 0;
      }
      break;

    case -1:
      if(SensorValue[touchl] == 0) {
        motor[lift1] = 127;
        motor[lift2] = 127;
        motor[lift3] = 127;
        motor[lift4] = 127;
        goal_lock = 0;  //unlocks arm
        } else {
        motor[lift1] = 0;
        motor[lift2] = 0;
        motor[lift3] = 0;
        motor[lift4] = 0;
      }
      break;

    case  0:if(goal_lock == 0 ) {
        motor[lift1] = 0;
        motor[lift2] = 0;
        motor[lift3] = 0;
        motor[lift4] = 0;
        break;
      }//switch
    }

    // Finder: Claw
    switch(vexRT[Btn6D] - vexRT[Btn6U])
    {
    case  1:motor[Claw] = -127; //Close
      break;
    case -1:motor[Claw] = 127; //Open
      break;
    case  0:motor[Claw] = 0; //Do nothing
      break;
    }
    // Finder :Drive Train
    {	if(vexRT[Ch2] < 30 && vexRT[Ch2]> -30 && vexRT[Ch3] < 30 && vexRT[Ch3]> -30)
      {
        motor[DriveLF] = 0;
        motor[DriveRF] = 0;
        motor[DriveRB] = 0;
        motor[DriveLB] = 0;

      }
      motor[DriveLF] = vexRT[Ch2];//left frotn motor
      motor[DriveRF] = vexRT[Ch3];//front right motor
      motor[DriveRB] = vexRT[Ch3];//right back motors
      motor[driveLB] = vexRT[Ch2];//Back left motor

    }




    // Shuts all motors down
    {

      if(vexRT[Btn8U] == 1)
      {
        motor[port1] = 0;
        motor[port6] = 0;
        motor[port7] = 0;
        motor[port10] = 0;



      }
    }

  }//while


}//taskusercontrol
