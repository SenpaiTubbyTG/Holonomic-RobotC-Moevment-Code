#pragma config(Sensor, in1,    frontleftline,       sensorLineFollower)
#pragma config(Sensor, in2,    frontmidline,        sensorLineFollower)
#pragma config(Sensor, in3,    frontrightline,      sensorLineFollower)
#pragma config(Sensor, in4,    rearleftline,        sensorLineFollower)
#pragma config(Sensor, in5,    rearmidline,         sensorLineFollower)
#pragma config(Sensor, in6,    rearrightline,       sensorLineFollower)
#pragma config(Sensor, in7,    leftwingline,        sensorLineFollower)
#pragma config(Sensor, in8,    rightwingline,       sensorLineFollower)
#pragma config(Sensor, in9,    liftpot,             sensorPotentiometer)
#pragma config(Sensor, in10,   leftsonar,           sensorSONAR, int1)
#pragma config(Sensor, in11,   rightsonar,          sensorSONAR, int2)
#pragma config(Sensor, in12,   leftencoder,         sensorQuadEncoder, int3)
#pragma config(Sensor, in13,   rightencoder,        sensorQuadEncoder, int4)
#pragma config(Sensor, in14,   goalbuttonL,         sensorTouch)
#pragma config(Sensor, in15,   ringbuttonR,         sensorTouch)
#pragma config(Sensor, in16,   pneumatics,          sensorDigitalOut)
#pragma config(Motor,  port1,           leftmotor,     tmotorNormal, openLoop)
#pragma config(Motor,  port2,           rightmotor,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           leftsmall,     tmotorNormal, openLoop)
#pragma config(Motor,  port4,           rightsmall,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port5,           lift1,         tmotorNormal, openLoop)
#pragma config(Motor,  port6,           lift2,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           intake,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           descore,       tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*
2921A
FREE RANGE ROBOTICS
full code for worlds 2011

Select program number and starting colour

PROGRAM 1:
Picks up the close stack, curves, and reverses to between wall goal and
single low goal.
spins to low goal, scores, and throws it under the ladder

Program 2:
<<<<<<<<<<<<<<<<<<<<<DISCONTINUED>>>>>>>>>>>>>>>>>>>>>>
scored preload on and moved closest goal fast, picked up stack,
and merged into program 1
##half removed from code##

Program 3:
preload cheater tube
Picks up close stack, and scores on the closer of the two low goals

Program 4:
Starts from any tile
picks up close stack and scores on corner low goal

Program 5:
Scores with cheater-tube, then spins, picks up stack, and scores on
corner low goal
*/


#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(180)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "Variable_Definitions.c"
#include "Raise_Arm_To_Position.c"
#include "Functions.c"


void pre_auton()
{
  bLCDBacklight = true;
  displayLCDPos(0,0);
  displayNextLCDString("program select");
  redteam = true;
  screenrefresh();
  time1[T1] = 0;
  while (programselecting == true && time1[T1] < 6000)
  {
    if (nLCDButtons & kLeftButton)
    {
      while (nLCDButtons & kLeftButton)
      {
      }
      if (redteam == true)
      {
        redteam = false;
      }
      else if (redteam == false)
      {
        redteam = true;
      }
      screenrefresh();
    }
    if (nLCDButtons & kCenterButton)
    {
      while (nLCDButtons & kCenterButton)
      {
      }
      programselect = programselect+1;
      if (programselect == 6)
      {
        programselect = 1;
      }
      screenrefresh();
    }
    if (nLCDButtons & kRightButton)
    {
      clearLCDLine(0);
      clearLCDLine(1);
      displayLCDPos(0,0);
      displayNextLCDString("Robot ready");
      wait1Msec(300);
      displayNextLCDString(".");
      wait1Msec(300);
      displayNextLCDString(".");
      wait1Msec(300);
      displayNextLCDString(".");
      wait1Msec(500);
      bLCDBacklight = false;
      programselecting = false;
    }
  }
}
task autonomous()
{
  clearencoders();
  motor[descore] = 127;
  SensorValue[pneumatics] = 0;
  time1[T4] = 0;
  motor[descore] = 20;

/*
  if (programselect == 2)
  {
    targetarmposition = stackheight;
    StartTask(raisearmtoposition);
    while (armraising == true)
    {
    }
    clearencoders();
    targetspeed = 80;
    rampto();
    while (SensorValue[leftencoder] + SensorValue[rightencoder] < 180)
    {
      drivestraight();
    }
    targetspeed = -40;
    instantspeed();
    wait1Msec(40);
    stopdrive();
    getstack();
    targetspeed = -120;
    rampto();
    while (SensorValue[leftencoder] + SensorValue[rightencoder] > -2500)
    {
      drivestraight();
    }
    targetspeed = 60;
    instantspeed();
    wait1Msec(40);
    stopdrive();
  }
  */

  if (programselect == 2)
  {


     }

     if (programselect == 1)
     {
       targetarmposition = stackheight;
       StartTask(raisearmtoposition);
       while (armraising == true)
       {
       }
       distance = 180;
       targetspeed = 100;
       forwardto();
       //distance = 470;

    //targetarmposition = stackheight-20;
    //StartTask(raisearmtoposition);


         }
  if (programselect < 3)
  {



    getstack();
    clearencoders();
    if (redteam == true)
    {

      curve(-127, -5, -550);

  }
    if (redteam == false)
    {
    curve(-5, -127, -460);
  }
    stopdrive();
    targetspeed = -120;
    instantspeed();
    clearencoders();
    while (SensorValue[leftencoder] + SensorValue[rightencoder] > -2700)
    {
      drivestraight();
    }
    while (SensorValue[leftsonar] > 42 | SensorValue[leftsonar] < 20 && SensorValue[rightsonar] > 42 | SensorValue[leftsonar] < 20)
    {
    }
    targetspeed = 80;
    instantspeed();
    wait1Msec(80);
    stopdrive();
    wait1Msec(100);
  }


  if (programselect == 1)
  {
    wait1Msec(300);
    targetarmposition = basefromdown;
    StartTask(raisearmtoposition);
    power = 80;
    spinamount = quarter;
    if (redteam == false)
    {
      cwturn();
    }
    if (redteam == true)
    {
      ccwturn();
    }
    wait1Msec(100);
    linetowall();
    scoreongoal();

    wait1Msec(1600);
    motor[intake] = 127;
    targetspeed = 80;
    rampto();
    while (SensorValue[ringbuttonR] == 0)
    {
    }
    stopdrive();
    targetarmposition = armmax;
    StartTask(raisearmtoposition);
    power = 120;
    if (redteam == true)
    {
      spinamount = quarter/2;
      cwturn();
    }
    if (redteam == false)
    {
      spinamount = quarter/2;
      ccwturn();
    }
    wait1Msec(100);
    clearencoders();
    targetspeed = 120;
    rampto();
    wait1Msec(700);
    stopdrive();
    SensorValue[pneumatics] = 1;
    wait1Msec(500);
    targetspeed = -127;
    instantspeed();
    wait1Msec(500);
    stopdrive();
    SensorValue[pneumatics] = 0;
    /*
    targetspeed = -60;
    distance = -500;
    backto();
    linetowall();
    targetarmposition = wallgoalheight;
    StartTask(raisearmtoposition);
    spinamount = quarter*2;
    spinamount = spinamount+80;
    power = 100;
    cwturn();
    wait1Msec(100);
    targetspeed = 100;
    rampto();
    bumpandstop();
    /*
    motor[descore] = -127;
    wait1Msec(200);
    motor[descore] = 0;
    linetowall();
    targetspeed = 100;
    rampto();
    while (SensorValue[leftsonar] < 26 && SensorValue[rightsonar] < 26)
    {
      drivestraight();
    }
    targetspeed = -50;
    instantspeed();
    wait1Msec(60);
    stopdrive();
    targetarmposition = basefromdown;
    StartTask(raisearmtoposition);
    while (armraising == true)
    {
    }
    scoreongoal();
    wait1Msec(1200);
    motor[intake] = 127;
    */
    //motor[intake] = -127;

  }


  if (programselect == 3)
  {
    targetarmposition = stackheight;
    StartTask(raisearmtoposition);
    targetspeed = 50;
    rampto();
    while (SensorValue[leftsonar] + SensorValue[rightsonar] < 12)
    {
    }
    targetspeed = -30;
    instantspeed();
    wait1Msec(50);
    stopdrive();
    wait1Msec(300);
    power = 80;
    spinamount = quarter;
    if (redteam == true)
    {
      cwturn();
    }
    if (redteam == false)
    {
      ccwturn();
    }
    targetspeed = 100;
    distance = 240;
    forwardto();
    getstack();
    clearencoders();
    if (redteam == true)
    {
     curve(-40, -127, -1150);
      spinamount = 370;
      power = 80;
      cwturn();
    }
    if (redteam == false)
    {
      curve(-127, -35, -1270);
      spinamount = 345;
      power = 80;
      ccwturn();
    }
    targetarmposition = basefromdown;
    StartTask(raisearmtoposition);
    scoreongoal();
    wait1Msec(1200);
    motor[intake] = 127;
  }
  if (programselect == 5)
  {
    targetarmposition = stackheight;
    StartTask(raisearmtoposition);
    targetspeed = 40;
    rampto();
    wait1Msec(100);
    while (SensorValue[leftsonar] + SensorValue[rightsonar] < 12)
    {
    }
    stopdrive();
    wait1Msec(300);
    power = 80;
    spinamount = quarter;
    if (redteam == true)
    {
      cwturn();
    }
    if (redteam == false)
    {
      ccwturn();
    }
    targetspeed = 100;
    distance = 240;
  }
  if (programselect == 4)
  {
    distance = 220;
    targetarmposition = stackheight;
    StartTask(raisearmtoposition);
  }
  if (programselect > 3)
  {
    while(armraising == true)
    {
    }
    targetspeed = 100;
    forwardto();
    getstack();
    targetarmposition = basefromdown;
    StartTask(raisearmtoposition);
    if (redteam == true)
    {
      spinamount = 90;
      ccwturn();
    }
    if (redteam == false)
    {
      spinamount = 90;
      cwturn();
    }
    while (armraising == true)
    {
    }
    scoreongoal();
    wait1Msec(1750);
    motor[intake] = 127;
  }


}
task usercontrol()
{
  allMotorsOff();
  armraising = false;
  StopTask(raisearmtoposition);
#include "Drive_Control.c"
}
