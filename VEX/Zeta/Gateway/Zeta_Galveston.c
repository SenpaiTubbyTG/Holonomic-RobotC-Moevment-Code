#pragma config(Motor,  port1,           frontR,        tmotorNormal, openLoop)
#pragma config(Motor,  port2,           backRTop,      tmotorNormal, openLoop)
#pragma config(Motor,  port3,           backRBottom,   tmotorNormal, openLoop)
#pragma config(Motor,  port4,           backLTop,      tmotorNormal, openLoop)
#pragma config(Motor,  port5,           backLBottom,   tmotorNormal, openLoop)
#pragma config(Motor,  port6,           armRTop,       tmotorNormal, openLoop)
#pragma config(Motor,  port7,           armRBottom,    tmotorNormal, openLoop)
#pragma config(Motor,  port8,           armLTop,       tmotorNormal, openLoop)
#pragma config(Motor,  port9,           armLBottom,    tmotorNormal, openLoop)
#pragma config(Motor,  port10,          frontL,        tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define FULL 127

/*Set Drive Right Speed*/
void setDriveRSpeed(int speed) {
  motor[backRTop] = motor[backRBottom] = motor[frontR] = speed;
}

void setDriveLSpeed(int speed) {
  motor[backLTop] = motor[backLBottom] = motor[frontL] = speed;
}

void setArmSpeed(int speed) {
  motor[armRTop] = motor[armRBottom] = motor[armLTop] = motor[armLBottom] = speed;
}

/*Kill Drive Train Motors*/
void killdrive() {
  setDriveLSpeed(0);
  setDriveRSpeed(0);
}

void drive_forward_msec(int speed, int duration) {
  setDriveLSpeed(speed);
  wait1Msec(duration);
  killdrive();
}

/*Kill Arm Motors*/
void killarm() {
  setArmSpeed(0);
}
void pre_auton()
{
}

task autonomous()
{

drive_forward_msec(127, 3000);

}

task usercontrol()
{

  while (true)
  {
    motor[frontR] = motor[backRTop] = motor[backRBottom] = vexRT[Ch2];
    motor[frontL] = motor[backLTop] = motor[backLBottom] = vexRT[Ch3];

    setDriveRSpeed(vexRT[Ch2]);// (y - x)
    setDriveLSpeed(vexRT[Ch3]);// (y + x)

//  motor[SuckL] = motor[SuckR] = (vexRT[Btn6U] - vexRT[Btn6D]) * FULL;

    setArmSpeed((vexRT[Btn6U] - vexRT[Btn6D])*FULL);

    }
}
