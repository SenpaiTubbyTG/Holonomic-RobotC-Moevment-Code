#pragma config(Motor,  port1,           frontR,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port2,           backRTop,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           backRBottom,   tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           frontRTop,     tmotorNormal, openLoop)
#pragma config(Motor,  port5,           backLTop,      tmotorNormal, openLoop)
#pragma config(Motor,  port6,           backLBottom,   tmotorNormal, openLoop)
#pragma config(Motor,  port7,           frontLTop,     tmotorNormal, openLoop)
#pragma config(Motor,  port8,           suckR,         tmotorNormal, openLoop)
#pragma config(Motor,  port9,           suckL,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port10,          frontL,        tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define FULL 127

/*Set Drive Right Speed*/
void setDriveRSpeed(int speed) {
  motor[backRTop] = motor[backRBottom] = motor[frontR] = motor[frontRTop] = speed;
}

void setDriveLSpeed(int speed) {
  motor[backLTop] = motor[backLBottom] = motor[frontL] = motor[frontLTop] = speed;
}

void setSuckSpeed(int speed) {
  motor[suckR] = speed;
  motor[suckL] = speed;
}

/*Kill Drive Train Motors*/
void killdrive() {
  setDriveLSpeed(0);
  setDriveRSpeed(0);
}

void drive_forward_msec(int speed, int duration) {
  setDriveLSpeed(speed);
  wait1Msec(duration);
  killdrive();
}

/*Kill Arm Motors*/
void killSuck() {
  setSuckSpeed(0);
}
void pre_auton()
{
}

task autonomous()
{

drive_forward_msec(127, 3000);

}

task usercontrol()
{

  while (true)
  {
//
//    motor[frontR] = motor[backRTop] = motor[backRBottom] = motor[frontRTop] = vexRT[Ch2];
//    motor[frontL] = motor[backLTop] = motor[backLBottom] = motor[frontLTop] = vexRT[Ch3];
//
    setDriveRSpeed(vexRT[Ch2]);//
    setDriveLSpeed(vexRT[Ch3]);//
//
    setSuckRSpeed((vexRT[Btn6U] - vexRT[Btn6D])*FULL);
    setSuckLSpeed((vexRT[Btn6U] - vexRT[Btn6D])*FULL);

    }
}
